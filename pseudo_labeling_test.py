# -*- coding: utf-8 -*-
"""누락데이터 복원 테스트.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17uRl-oWRekupweDdpPkoDitBP6ufLf2P
"""

# 나눔고딕 모든 스타일 다운로드
font_files = {
    "NanumGothic-Regular.ttf": "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Regular.ttf",
    "NanumGothic-Bold.ttf": "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf",
    "NanumGothic-ExtraBold.ttf": "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-ExtraBold.ttf"
}

for filename, url in font_files.items():
    !wget -O "{font_dir}/{filename}" "{url}"

print("모든 나눔고딕 폰트 다운로드 완료!")

import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import warnings
warnings.filterwarnings('ignore')

font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'  # 또는 Regular, ExtraBold

# 폰트 등록
fm.fontManager.addfont(font_path)
font_prop = fm.FontProperties(fname=font_path)
font_name = font_prop.get_name()

plt.rc('font', family=font_name)
plt.rcParams['axes.unicode_minus'] = False

print(f"한글 폰트 설정 완료: {font_name}")

plt.figure(figsize=(6, 3))
plt.title("한글 제목 테스트")
plt.xlabel("X축 라벨")
plt.ylabel("Y축 라벨")
plt.text(0.5, 0.5, "한글 테스트 문구", fontsize=14, ha='center')
plt.show()

from google.colab import files
files.upload()  # 다운로드한 kaggle.json 파일을 업로드

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json  # 보안을 위해 권한 설정

!pip install kaggle

# 데이터 불러오기
!kaggle competitions download -c ai04-level1-project

!unzip ai04-level1-project.zip -d ./data/

import os
print(os.listdir('./data'))  # 압축 해제된 폴더 내 파일 확인

!pip install ultralytics

import os
import json
import shutil
import random
from pathlib import Path
from sklearn.model_selection import train_test_split
import cv2

ANNOTATION_BASE_DIR = './data/train_annotations'
OUTPUT_DIR = './yolo_dataset'

# 출력 폴더 생성
Path(f"{OUTPUT_DIR}/images/train").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/images/val").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/labels/train").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/labels/val").mkdir(parents=True, exist_ok=True)

# 클래스 이름 → ID 매핑

class_name_to_id = {}
next_class_id = 0

json_paths = []
for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_paths.append(os.path.join(root, file))

for json_path in json_paths:
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            if 'root' in data and isinstance(data['root'], dict):
                data = data['root']

            if 'categories' not in data or not isinstance(data.get('categories'), list):
                continue

            for cat in data['categories']:
                # 수정: if isinstance(cat, dict) and 'name' in cat 으로 변경
                if isinstance(cat, dict) and 'name' in cat:
                    name = cat['name']
                    if name not in class_name_to_id:
                        class_name_to_id[name] = next_class_id
                        next_class_id += 1
    except Exception as e: # Added exception handling for parsing errors
        print(f"Error parsing {json_path}: {e}")
        continue

print(f"총 클래스 수: {len(class_name_to_id)}")
with open(f"{OUTPUT_DIR}/classes.txt", 'w', encoding='utf-8') as f:
    for name in sorted(class_name_to_id.keys(), key=lambda x: class_name_to_id[x]):
        f.write(name + '\n')

def convert_coco_to_yolo(bbox, img_width, img_height):
    x, y, w, h = bbox
    x_center = (x + w / 2) / img_width
    y_center = (y + h / 2) / img_height
    w_norm = w / img_width
    h_norm = h / img_height
    return x_center, y_center, w_norm, h_norm

# Define IMAGE_DIR
IMAGE_DIR = './data/train_images'

# 완전한 어노테이션을 가진 이미지 수집
complete_images = []

image_files = [f for f in os.listdir(IMAGE_DIR) if f.endswith('.png')]

for image_filename in image_files:
    prefix_part = image_filename.split('_')[0]  # "K-001900-010224-016551-031705"
    prefixes_raw = prefix_part.split('-')[1:]   # ['001900', '010224', '016551', '031705']
    prefix_folders = [f"K-{p}" for p in prefixes_raw]

    # ✅ 동적: 이 이미지에 필요한 어노테이션 개수 = 접두사 개수
    required_count = len(prefixes_raw)

    annotation_folder_name = prefix_part + "_json"
    annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

    if not os.path.exists(annotation_folder_path):
        continue

    found_count = 0
    for folder_name in prefix_folders:
        subfolder_path = os.path.join(annotation_folder_path, folder_name)
        if not os.path.exists(subfolder_path):
            break  # 폴더가 없으면 완전하지 않음

        json_filename = os.path.splitext(image_filename)[0] + ".json"
        json_path = os.path.join(subfolder_path, json_filename)

        if not os.path.exists(json_path):
            break  # JSON이 없으면 완전하지 않음

        found_count += 1

    # ✅ 수정: required_count 개수만큼 있어야 포함
    if found_count == required_count:
        complete_images.append(image_filename)

print(f"완전한 어노테이션을 가진 이미지 수: {len(complete_images)}")

if len(complete_images) == 0:
    raise ValueError("완전한 어노테이션을 가진 이미지가 없습니다!")

train_images, val_images = train_test_split(complete_images, test_size=0.2, random_state=42)
print(f"Train: {len(train_images)}, Val: {len(val_images)}")

def process_image_list(image_list, split):
    image_target_dir = f"{OUTPUT_DIR}/images/{split}"
    label_target_dir = f"{OUTPUT_DIR}/labels/{split}"

    for image_filename in image_list:
        # 이미지 복사
        src_img_path = os.path.join(IMAGE_DIR, image_filename)
        dst_img_path = os.path.join(image_target_dir, image_filename)
        shutil.copy2(src_img_path, dst_img_path)

        # 라벨 파일 생성
        label_filename = os.path.splitext(image_filename)[0] + ".txt"
        label_path = os.path.join(label_target_dir, label_filename)

        prefix_part = image_filename.split('_')[0]
        prefixes_raw = prefix_part.split('-')[1:]
        prefix_folders = [f"K-{p}" for p in prefixes_raw]
        annotation_folder_name = prefix_part + "_json"
        annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

        # 이미지 크기 읽기
        img = cv2.imread(src_img_path)
        if img is None:
            print(f"이미지 로드 실패: {src_img_path}")
            continue
        img_height, img_width = img.shape[:2]

        with open(label_path, 'w', encoding='utf-8') as f:
            for folder_name in prefix_folders:
                subfolder_path = os.path.join(annotation_folder_path, folder_name)
                json_filename = os.path.splitext(image_filename)[0] + ".json"
                json_path = os.path.join(subfolder_path, json_filename)

                # 파일이 없으면 건너뜀 (이론상 여기까지 오면 모두 있어야 함)
                if not os.path.exists(json_path):
                    continue

                try:
                    with open(json_path, 'r', encoding='utf-8') as jf:
                        data = json.load(jf)
                        if 'root' in data and isinstance(data['root'], dict):
                            data = data['root']

                        # 이미지 ID 찾기
                        image_id = None
                        for img_info in data.get('images', []):
                            if img_info.get('file_name') == image_filename:
                                image_id = img_info['id']
                                break

                        if image_id is None:
                            continue

                        # 해당 image_id의 annotations 찾기
                        annotations = [
                            ann for ann in data.get('annotations', [])
                            if ann.get('image_id') == image_id
                        ]

                        for ann in annotations:
                            bbox = ann.get('bbox')
                            if not bbox or len(bbox) != 4:
                                continue

                            category_id = ann.get('category_id')
                            cat_name = None
                            for cat in data.get('categories', []):
                                if cat.get('id') == category_id:
                                    cat_name = cat.get('name')
                                    break

                            if cat_name is None or cat_name not in class_name_to_id:
                                continue

                            cls_id = class_name_to_id[cat_name]
                            x_center, y_center, w_norm, h_norm = convert_coco_to_yolo(bbox, img_width, img_height)
                            f.write(f"{cls_id} {x_center:.6f} {y_center:.6f} {w_norm:.6f} {h_norm:.6f}\n")

                except Exception as e:
                    print(f"파싱 오류: {json_path} - {e}")
                    continue

# Train 처리
print("Train 이미지 처리 중...")
process_image_list(train_images, 'train')

# Val 처리
print("Val 이미지 처리 중...")
process_image_list(val_images, 'val')

print("YOLO 형식 변환 완료 (완전한 어노테이션만 사용)!")

import os

train_img_abs = os.path.abspath(f"{OUTPUT_DIR}/images/train")
val_img_abs = os.path.abspath(f"{OUTPUT_DIR}/images/val")

yaml_content = f"""train: {train_img_abs}
val: {val_img_abs}

nc: {len(class_name_to_id)}
names: {list(class_name_to_id.keys())}
"""

with open(f"{OUTPUT_DIR}/dataset.yaml", 'w', encoding='utf-8') as f:
    f.write(yaml_content)

print("dataset.yaml 생성 완료!")
print(f"Train 경로: {train_img_abs}")
print(f"Val 경로: {val_img_abs}")

from ultralytics import YOLO
import shutil
from datetime import datetime

# --- 저장 경로 설정 ---
DRIVE_BASE_PATH = '/content/drive/MyDrive/코드잇/파트2/초급 프로젝트/모델'
os.makedirs(DRIVE_BASE_PATH, exist_ok=True)

# --- 고유 폴더명 생성 (타임스탬프 + 모델명) ---
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
model_name = 'big_model'
unique_folder_name = f"pill_detection_{model_name}_{timestamp}"
DRIVE_MODEL_PATH = os.path.join(DRIVE_BASE_PATH, unique_folder_name)
os.makedirs(DRIVE_MODEL_PATH, exist_ok=True)

print(f"저장 폴더: {DRIVE_MODEL_PATH}")

# --- YOLOv8s 모델 로드 ---
big_model = YOLO('yolov8s.pt')

# --- 학습 실행 ---
results = big_model.train(
    data=f'{OUTPUT_DIR}/dataset.yaml',
    epochs=50,
    imgsz=640,
    batch=16,
    name='pill_detection_big_model',
    patience=10,
    save=True,
    plots=True,
    val=True,
    device=0
)

# --- 최종 성능 출력 ---
final_map = results.results_dict['metrics/mAP50-95(B)']
print(f"최종 mAP@0.5:0.95: {final_map:.4f}")

# --- 로컬 저장 경로 ---
local_best_path = results.save_dir / 'weights' / 'best.pt'
local_last_path = results.save_dir / 'weights' / 'last.pt'

# --- Google Drive에 복사 ---
drive_best_path = os.path.join(DRIVE_MODEL_PATH, 'best.pt')
drive_last_path = os.path.join(DRIVE_MODEL_PATH, 'last.pt')

# best.pt 복사
if os.path.exists(local_best_path):
    shutil.copy2(local_best_path, drive_best_path)
    print(f"best.pt 저장 완료: {drive_best_path}")
else:
    print(f"[오류] best.pt를 찾을 수 없습니다: {local_best_path}")

# last.pt 복사
if os.path.exists(local_last_path):
    shutil.copy2(local_last_path, drive_last_path)
    print(f"last.pt 저장 완료: {drive_last_path}")

# --- 전체 학습 폴더 백업 ---
run_dir = str(results.save_dir)
drive_run_dir = os.path.join(DRIVE_BASE_PATH, unique_folder_name + "_full")

if os.path.exists(run_dir):
    shutil.copytree(run_dir, drive_run_dir, dirs_exist_ok=True)
    print(f"전체 학습 폴더 백업 완료: {drive_run_dir}")

import os
import cv2
import shutil
from ultralytics import YOLO
from pathlib import Path

# --- 1. 설정 ---
MODEL_PATH = './runs/detect/pill_detection_big_model/weights/best.pt'
IMAGE_DIR = './data/train_images'
ANNOTATION_BASE_DIR = './data/train_annotations'
OUTPUT_DIR = './yolo_test_dataset'

# 출력 폴더 생성
Path(f"{OUTPUT_DIR}/images").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/labels").mkdir(parents=True, exist_ok=True)

# --- 2. 모델 로드 ---
model = YOLO(MODEL_PATH)
print(f"모델 로드 완료: {MODEL_PATH}")

# --- 3. 완전한 어노테이션을 가진 이미지 목록 추출 (접두사 개수 기반) ---
def get_complete_images():
    complete_images = set()
    image_files = [f for f in os.listdir(IMAGE_DIR) if f.endswith('.png')]

    for image_filename in image_files:
        prefix_part = image_filename.split('_')[0]
        prefixes_raw = prefix_part.split('-')[1:]
        prefix_folders = [f"K-{p}" for p in prefixes_raw]
        required_count = len(prefixes_raw)

        annotation_folder_name = prefix_part + "_json"
        annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

        if not os.path.exists(annotation_folder_path):
            continue

        found_count = 0
        for folder_name in prefix_folders:
            subfolder_path = os.path.join(annotation_folder_path, folder_name)
            if not os.path.exists(subfolder_path):
                break

            json_filename = os.path.splitext(image_filename)[0] + ".json"
            json_path = os.path.join(subfolder_path, json_filename)

            if not os.path.exists(json_path):
                break

            found_count += 1

        if found_count == required_count:
            complete_images.add(image_filename)

    return complete_images

complete_images = get_complete_images()
print(f"완전한 어노테이션을 가진 이미지 수: {len(complete_images)}")

# --- 4. 테스트 대상 이미지 (완전한 이미지 제외) ---
all_image_files = [f for f in os.listdir(IMAGE_DIR) if f.endswith('.png')]
test_image_names = [f for f in all_image_files if f not in complete_images]
print(f"테스트 대상 이미지 수: {len(test_image_names)}")

# --- 5. 클래스 이름 로드 ---
class_names = []
classes_path = './yolo_dataset/classes.txt'
if os.path.exists(classes_path):
    with open(classes_path, 'r', encoding='utf-8') as f:
        class_names = [line.strip() for line in f.readlines()]
    print(f"클래스 이름 로드 완료: {len(class_names)}개")

# --- 6. 각 테스트 이미지에 대해 추론 + 검증 + 저장 ---
generated_count = 0
passed_validation_count = 0
failed_validation_count = 0

for img_name in test_image_names:
    img_path = os.path.join(IMAGE_DIR, img_name)
    if not os.path.exists(img_path):
        print(f"이미지 없음: {img_path}")
        continue

    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        continue

    h, w = img.shape[:2]

    # ✅ 1. 이 이미지에 필요한 라벨 개수 계산 (접두사 개수)
    prefix_part = img_name.split('_')[0]
    prefixes_raw = prefix_part.split('-')[1:]
    required_label_count = len(prefixes_raw)

    # 추론 수행
    results = model.predict(img_path, conf=0.3, verbose=False)

    # 라벨 파일 경로
    label_name = os.path.splitext(img_name)[0] + ".txt"
    label_path = os.path.join(OUTPUT_DIR, 'labels', label_name)

    # ✅ 2. 추론 결과에서 탐지된 라벨 개수 계산
    detection_count = 0
    detected_labels = []

    for result in results:
        boxes = result.boxes
        for box in boxes:
            cls_id = int(box.cls[0])
            conf = float(box.conf[0])
            x_center, y_center, width, height = box.xywhn[0].tolist()
            detected_labels.append((cls_id, conf, x_center, y_center, width, height))
            detection_count += 1

    # ✅ 3. 검증: 탐지된 라벨 개수 == 필요한 라벨 개수?
    if detection_count == required_label_count:
        # ✅ 검증 통과 → 라벨 파일 저장 + 이미지 복사
        with open(label_path, 'w', encoding='utf-8') as f:
            for cls_id, conf, x_center, y_center, width, height in detected_labels:
                f.write(f"{cls_id} {x_center:.6f} {y_center:.6f} {width:.6f} {height:.6f}\n")

        img_dst_path = os.path.join(OUTPUT_DIR, 'images', img_name)
        shutil.copy2(img_path, img_dst_path)

        generated_count += 1
        passed_validation_count += 1

        # 콘솔 출력
        if class_names:
            labels_str = ", ".join([
                f"{class_names[cls_id] if cls_id < len(class_names) else f'Class{cls_id}'} ({conf:.2f})"
                for cls_id, conf, _, _, _, _ in detected_labels
            ])
            # print(f"{img_name} → {labels_str} [검증 통과: {detection_count}/{required_label_count}]")
    else:
        # ❌ 검증 실패
        failed_validation_count += 1
        print(f"{img_name} → 탐지: {detection_count}개, 필요: {required_label_count}개 → 검증 실패 (저장 안 함)")

print(f"\n 처리 결과 요약")
print(f"총 처리 이미지: {len(test_image_names)}")
print(f"라벨 생성 시도: {generated_count + failed_validation_count}")
print(f"검증 통과: {passed_validation_count}")
print(f"검증 실패: {failed_validation_count}")
print(f"최종 저장된 이미지: {passed_validation_count}")
print(f"저장 위치: {OUTPUT_DIR}")

# 기존 완전한 이미지 데이터셋 + 예측을 통해 생성한 이미지 데이터셋
import os
import shutil
from pathlib import Path

# --- 경로 설정 ---
COMPLETE_DATASET = './yolo_dataset'  # 완전한 어노테이션 데이터
PSEUDO_DATASET = './yolo_test_dataset'        # 의사 라벨 데이터
FINAL_DATASET = './final_dataset'

# --- 출력 폴더 구조 생성 ---
for split in ['train', 'val']:
    Path(f"{FINAL_DATASET}/images/{split}").mkdir(parents=True, exist_ok=True)
    Path(f"{FINAL_DATASET}/labels/{split}").mkdir(parents=True, exist_ok=True)

print("최종 데이터셋 폴더 구조 생성 완료")

def copy_dataset(src_root, dst_root, split):
    """데이터셋의 images와 labels을 복사"""
    src_img_dir = f"{src_root}/images/{split}"
    src_lbl_dir = f"{src_root}/labels/{split}"
    dst_img_dir = f"{FINAL_DATASET}/images/{split}"
    dst_lbl_dir = f"{FINAL_DATASET}/labels/{split}"

    if os.path.exists(src_img_dir):
        for fname in os.listdir(src_img_dir):
            if fname.endswith(('.png', '.jpg', '.jpeg')):
                shutil.copy2(os.path.join(src_img_dir, fname), os.path.join(dst_img_dir, fname))

    if os.path.exists(src_lbl_dir):
        for fname in os.listdir(src_lbl_dir):
            if fname.endswith('.txt'):
                shutil.copy2(os.path.join(src_lbl_dir, fname), os.path.join(dst_lbl_dir, fname))

# 완전한 데이터셋 복사 (train/val)
copy_dataset(COMPLETE_DATASET, FINAL_DATASET, 'train')
copy_dataset(COMPLETE_DATASET, FINAL_DATASET, 'val')

print("완전한 데이터셋 복사 완료")

# 복원한 이미지 데이터를 train에 추가 (val에는 추가하지 않음 → 평가용은 깨끗한 데이터 유지)
pseudo_img_dir = f"{PSEUDO_DATASET}/images"
pseudo_lbl_dir = f"{PSEUDO_DATASET}/labels"
final_train_img_dir = f"{FINAL_DATASET}/images/train"
final_train_lbl_dir = f"{FINAL_DATASET}/labels/train"

copied_count = 0
if os.path.exists(pseudo_img_dir):
    for fname in os.listdir(pseudo_img_dir):
        if fname.endswith(('.png', '.jpg', '.jpeg')):
            # 이미지 복사
            shutil.copy2(os.path.join(pseudo_img_dir, fname), os.path.join(final_train_img_dir, fname))
            # 라벨 복사
            label_name = os.path.splitext(fname)[0] + ".txt"
            src_label_path = os.path.join(pseudo_lbl_dir, label_name)
            if os.path.exists(src_label_path):
                shutil.copy2(src_label_path, os.path.join(final_train_lbl_dir, label_name))
                copied_count += 1

print(f"복원 라벨 데이터 {copied_count}개를 train에 병합 완료")

def count_files(dir_path, extension):
    if not os.path.exists(dir_path):
        return 0
    return len([f for f in os.listdir(dir_path) if f.endswith(extension)])

# 통계 출력
train_images = count_files(f"{FINAL_DATASET}/images/train", '.png')
train_labels = count_files(f"{FINAL_DATASET}/labels/train", '.txt')
val_images = count_files(f"{FINAL_DATASET}/images/val", '.png')
val_labels = count_files(f"{FINAL_DATASET}/labels/val", '.txt')

print("\n최종 데이터셋 통계")
print("="*40)
print(f"Train 이미지: {train_images}장")
print(f"Train 라벨: {train_labels}개")
print(f"Val 이미지: {val_images}장")
print(f"Val 라벨: {val_labels}개")
print("="*40)

import os

# 클래스 이름 로드
classes_path = './yolo_dataset/classes.txt'
if not os.path.exists(classes_path):
    raise FileNotFoundError(f"클래스 파일 없음: {classes_path}")

with open(classes_path, 'r', encoding='utf-8') as f:
    class_names = [line.strip() for line in f.readlines()]

# 절대 경로 사용
train_img_abs = os.path.abspath(f"{FINAL_DATASET}/images/train")
val_img_abs = os.path.abspath(f"{FINAL_DATASET}/images/val")

yaml_content = f"""train: {train_img_abs}
val: {val_img_abs}

nc: {len(class_names)}
names: {class_names}
"""

with open(f"{FINAL_DATASET}/final_dataset.yaml", 'w', encoding='utf-8') as f:
    f.write(yaml_content)

print("final_dataset.yaml 생성 완료")
print(f"Train 경로: {train_img_abs}")
print(f"Val 경로: {val_img_abs}")

from ultralytics import YOLO

# --- 저장 경로 설정 ---
DRIVE_BASE_PATH = '/content/drive/MyDrive/코드잇/파트2/초급 프로젝트/모델'
os.makedirs(DRIVE_BASE_PATH, exist_ok=True)

# --- 고유 폴더명 생성 (타임스탬프 + 모델명) ---
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
model_name = 'small_model'
unique_folder_name = f"pill_detection_{model_name}_{timestamp}"
DRIVE_MODEL_PATH = os.path.join(DRIVE_BASE_PATH, unique_folder_name)
os.makedirs(DRIVE_MODEL_PATH, exist_ok=True)

print(f"저장 폴더: {DRIVE_MODEL_PATH}")

# --- YOLOv8s 모델 로드 ---
small_model = YOLO('yolov8s.pt')

# --- 학습 실행 ---
results = small_model.train(
    data=f'final_dataset/final_dataset.yaml',
    epochs=50,
    imgsz=640,
    batch=16,
    name='pill_detection_small_model',
    patience=10,
    save=True,
    plots=True,
    val=True,
    device=0
)

# --- 최종 성능 출력 ---
final_map = results.results_dict['metrics/mAP50-95(B)']
print(f"최종 mAP@0.5:0.95: {final_map:.4f}")

# --- 로컬 저장 경로 ---
local_best_path = results.save_dir / 'weights' / 'best.pt'
local_last_path = results.save_dir / 'weights' / 'last.pt'

# --- Google Drive에 복사 ---
drive_best_path = os.path.join(DRIVE_MODEL_PATH, 'best.pt')
drive_last_path = os.path.join(DRIVE_MODEL_PATH, 'last.pt')

# best.pt 복사
if os.path.exists(local_best_path):
    shutil.copy2(local_best_path, drive_best_path)
    print(f"best.pt 저장 완료: {drive_best_path}")
else:
    print(f"[오류] best.pt를 찾을 수 없습니다: {local_best_path}")

# last.pt 복사
if os.path.exists(local_last_path):
    shutil.copy2(local_last_path, drive_last_path)
    print(f"last.pt 저장 완료: {drive_last_path}")

# --- 전체 학습 폴더 백업 ---
run_dir = str(results.save_dir)
drive_run_dir = os.path.join(DRIVE_BASE_PATH, unique_folder_name + "_full")

if os.path.exists(run_dir):
    shutil.copytree(run_dir, drive_run_dir, dirs_exist_ok=True)
    print(f"전체 학습 폴더 백업 완료: {drive_run_dir}")

import os
import cv2
import matplotlib.pyplot as plt
from ultralytics import YOLO
from PIL import Image, ImageDraw, ImageFont
import numpy as np

# --- 1. 학습된 모델 로드 final (복원) ---
MODEL_PATH = './runs/detect/pill_detection_small_model7/weights/best.pt'  # ← 학습된 모델 경로
TEST_IMAGE_DIR = './data/test_images'
OUTPUT_VIS_DIR = './test_results_visualized'  # 시각화 결과 저장 폴더

# 출력 폴더 생성
os.makedirs(OUTPUT_VIS_DIR, exist_ok=True)

# 모델 로드
model = YOLO(MODEL_PATH)
print(f"모델 로드 완료: {MODEL_PATH}")

# --- 2. 클래스 이름 로드 ---
classes_path = './final_dataset/final_dataset.yaml'  # 또는 './yolo_dataset_complete/classes.txt'
class_names = []

# YAML 파일에서 names 추출
if os.path.exists(classes_path) and classes_path.endswith('.yaml'):
    with open(classes_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
        for line in lines:
            if line.strip().startswith('names:'):
                # names: ['클래스1', '클래스2', ...] 형식 파싱
                names_str = line.split('names:', 1)[1].strip()
                # 리스트 형식 파싱
                if names_str.startswith('[') and names_str.endswith(']'):
                    names_str = names_str[1:-1]
                    class_names = [name.strip().strip("'\"") for name in names_str.split(',')]
                break
elif os.path.exists('./yolo_dataset_complete/classes.txt'):
    with open('./yolo_dataset_complete/classes.txt', 'r', encoding='utf-8') as f:
        class_names = [line.strip() for line in f.readlines()]

print(f"클래스 이름 로드 완료: {len(class_names)}개")

# --- 3. 한글 폰트 설정 (PIL용) ---
def setup_korean_font():
    """안정적인 한글 폰트 설정"""
    font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'

    # 폰트 파일 없으면 자동 다운로드
    if not os.path.exists(font_path):
        os.makedirs(os.path.dirname(font_path), exist_ok=True)
        print("폰트 다운로드 중...")
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf" 2> /dev/null || \
           wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf" 2> /dev/null

    # 폰트 로드 시도
    try:
        font = ImageFont.truetype(font_path, 20)
        print(f"한글 폰트 로드 성공: {font_path}")
        return font
    except Exception as e:
        print(f"폰트 로드 실패: {e} → 기본 폰트 사용")
        return ImageFont.load_default()

# 폰트 설정
font = setup_korean_font()

# --- 4. OpenCV 이미지에 한글 그리기 함수 ---
def put_text_korean(img, text, position, color):
    """
    OpenCV 이미지에 한글 텍스트 그리기 (PIL 사용)
    """
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)
    draw.text(position, text, font=font, fill=color[::-1])  # RGB
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

# --- 5. 테스트 이미지 목록 가져오기 ---
if not os.path.exists(TEST_IMAGE_DIR):
    raise FileNotFoundError(f"테스트 이미지 폴더 없음: {TEST_IMAGE_DIR}")

test_image_paths = [
    os.path.join(TEST_IMAGE_DIR, f)
    for f in os.listdir(TEST_IMAGE_DIR)
    if f.lower().endswith(('.png', '.jpg', '.jpeg'))
]

print(f"총 {len(test_image_paths)}개 테스트 이미지 로드됨")

# ✅ 랜덤으로 10개 선택 (전체 개수보다 작으면 전체 사용)
sample_size = min(10, len(test_image_paths))
random_image_paths = random.sample(test_image_paths, sample_size)

print(f"랜덤 선택된 이미지 {sample_size}개:")
for i, path in enumerate(random_image_paths, 1):
    print(f"  {i}. {os.path.basename(path)}")

# --- 6. 각 이미지에 대해 추론 + 시각화 ---
for i, img_path in enumerate(random_image_paths):  # ✅ 수정: random_image_paths 사용
    print(f"\n처리 중 ({i+1}/{sample_size}): {os.path.basename(img_path)}")

    # 이미지 로드
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        continue

    # 추론
    results = model.predict(img_path, conf=0.3, verbose=False)

    # 시각화용 이미지 복사
    img_vis = img.copy()

    detection_count = 0
    for result in results:
        boxes = result.boxes
        for box in boxes:
            # 좌표 추출 (안전한 방식)
            xyxy = box.xyxy.cpu().numpy().flatten()
            if len(xyxy) != 4:
                print(f"잘못된 좌표 형식: {xyxy}")
                continue

            x1, y1, x2, y2 = map(int, xyxy)
            conf = float(box.conf.cpu().numpy())
            cls_id = int(box.cls.cpu().numpy())

            # 클래스 이름
            label = class_names[cls_id] if cls_id < len(class_names) else f"Class {cls_id}"
            text = f"{label} {conf:.2f}"

            # 좌표 유효성 검사
            if x1 < 0 or y1 < 0 or x2 > img_vis.shape[1] or y2 > img_vis.shape[0]:
                print(f"좌표가 이미지 범위를 벗어남: ({x1}, {y1}, {x2}, {y2})")
                continue

            # 박스 그리기
            cv2.rectangle(img_vis, (x1, y1), (x2, y2), (0, 255, 0), 3)
            print(f"박스 그림: {label} at ({x1}, {y1}, {x2}, {y2})")

            # 한글 텍스트 그리기
            img_vis = put_text_korean(img_vis, text, (x1, y1 - 25), (0, 255, 0))

            detection_count += 1

    print(f"탐지된 객체 수: {detection_count}")

    # Matplotlib로 시각화
    plt.figure(figsize=(12, 8))
    plt.imshow(cv2.cvtColor(img_vis, cv2.COLOR_BGR2RGB))
    plt.title(f"테스트 결과: {os.path.basename(img_path)}", fontsize=14, weight='bold')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    # 결과 이미지 저장
    output_path = os.path.join(OUTPUT_VIS_DIR, os.path.basename(img_path))
    cv2.imwrite(output_path, img_vis)
    print(f"결과 저장: {output_path}")

import os
import cv2
import matplotlib.pyplot as plt
from ultralytics import YOLO
from PIL import Image, ImageDraw, ImageFont
import numpy as np

# --- 1. 학습된 모델 로드 big model ---
MODEL_PATH = './runs/detect/pill_detection_big_model4/weights/best.pt'  # ← 학습된 모델 경로
TEST_IMAGE_DIR = './data/test_images'
OUTPUT_VIS_DIR = './test_results_visualized'  # 시각화 결과 저장 폴더

# 출력 폴더 생성
os.makedirs(OUTPUT_VIS_DIR, exist_ok=True)

# 모델 로드
model = YOLO(MODEL_PATH)
print(f"모델 로드 완료: {MODEL_PATH}")

# --- 2. 클래스 이름 로드 ---
classes_path = './final_dataset/final_dataset.yaml'  # 또는 './yolo_dataset_complete/classes.txt'
class_names = []

# YAML 파일에서 names 추출
if os.path.exists(classes_path) and classes_path.endswith('.yaml'):
    with open(classes_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
        for line in lines:
            if line.strip().startswith('names:'):
                # names: ['클래스1', '클래스2', ...] 형식 파싱
                names_str = line.split('names:', 1)[1].strip()
                # 리스트 형식 파싱
                if names_str.startswith('[') and names_str.endswith(']'):
                    names_str = names_str[1:-1]
                    class_names = [name.strip().strip("'\"") for name in names_str.split(',')]
                break
elif os.path.exists('./yolo_dataset_complete/classes.txt'):
    with open('./yolo_dataset_complete/classes.txt', 'r', encoding='utf-8') as f:
        class_names = [line.strip() for line in f.readlines()]

print(f"클래스 이름 로드 완료: {len(class_names)}개")

# --- 3. 한글 폰트 설정 (PIL용) ---
def setup_korean_font():
    """안정적인 한글 폰트 설정"""
    font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'

    # 폰트 파일 없으면 자동 다운로드
    if not os.path.exists(font_path):
        os.makedirs(os.path.dirname(font_path), exist_ok=True)
        print("폰트 다운로드 중...")
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf" 2> /dev/null || \
           wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf" 2> /dev/null

    # 폰트 로드 시도
    try:
        font = ImageFont.truetype(font_path, 20)
        print(f"한글 폰트 로드 성공: {font_path}")
        return font
    except Exception as e:
        print(f"폰트 로드 실패: {e} → 기본 폰트 사용")
        return ImageFont.load_default()

# 폰트 설정
font = setup_korean_font()

# --- 4. OpenCV 이미지에 한글 그리기 함수 ---
def put_text_korean(img, text, position, color):
    """
    OpenCV 이미지에 한글 텍스트 그리기 (PIL 사용)
    """
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)
    draw.text(position, text, font=font, fill=color[::-1])  # RGB
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

# --- 5. 테스트 이미지 목록 가져오기 ---
if not os.path.exists(TEST_IMAGE_DIR):
    raise FileNotFoundError(f"테스트 이미지 폴더 없음: {TEST_IMAGE_DIR}")

test_image_paths = [
    os.path.join(TEST_IMAGE_DIR, f)
    for f in os.listdir(TEST_IMAGE_DIR)
    if f.lower().endswith(('.png', '.jpg', '.jpeg'))
]

print(f"총 {len(test_image_paths)}개 테스트 이미지 로드됨")

# ✅ 랜덤으로 10개 선택 (전체 개수보다 작으면 전체 사용)
sample_size = min(10, len(test_image_paths))
random_image_paths = random.sample(test_image_paths, sample_size)

print(f"랜덤 선택된 이미지 {sample_size}개:")
for i, path in enumerate(random_image_paths, 1):
    print(f"  {i}. {os.path.basename(path)}")

# --- 6. 각 이미지에 대해 추론 + 시각화 ---
for i, img_path in enumerate(random_image_paths):  # ✅ 수정: random_image_paths 사용
    print(f"\n처리 중 ({i+1}/{sample_size}): {os.path.basename(img_path)}")

    # 이미지 로드
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        continue

    # 추론
    results = model.predict(img_path, conf=0.3, verbose=False)

    # 시각화용 이미지 복사
    img_vis = img.copy()

    detection_count = 0
    for result in results:
        boxes = result.boxes
        for box in boxes:
            # 좌표 추출 (안전한 방식)
            xyxy = box.xyxy.cpu().numpy().flatten()
            if len(xyxy) != 4:
                print(f"잘못된 좌표 형식: {xyxy}")
                continue

            x1, y1, x2, y2 = map(int, xyxy)
            conf = float(box.conf.cpu().numpy())
            cls_id = int(box.cls.cpu().numpy())

            # 클래스 이름
            label = class_names[cls_id] if cls_id < len(class_names) else f"Class {cls_id}"
            text = f"{label} {conf:.2f}"

            # 좌표 유효성 검사
            if x1 < 0 or y1 < 0 or x2 > img_vis.shape[1] or y2 > img_vis.shape[0]:
                print(f"좌표가 이미지 범위를 벗어남: ({x1}, {y1}, {x2}, {y2})")
                continue

            # 박스 그리기
            cv2.rectangle(img_vis, (x1, y1), (x2, y2), (0, 255, 0), 3)
            print(f"박스 그림: {label} at ({x1}, {y1}, {x2}, {y2})")

            # 한글 텍스트 그리기
            img_vis = put_text_korean(img_vis, text, (x1, y1 - 25), (0, 255, 0))

            detection_count += 1

    print(f"탐지된 객체 수: {detection_count}")

    # Matplotlib로 시각화
    plt.figure(figsize=(12, 8))
    plt.imshow(cv2.cvtColor(img_vis, cv2.COLOR_BGR2RGB))
    plt.title(f"테스트 결과: {os.path.basename(img_path)}", fontsize=14, weight='bold')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    # 결과 이미지 저장
    output_path = os.path.join(OUTPUT_VIS_DIR, os.path.basename(img_path))
    cv2.imwrite(output_path, img_vis)
    print(f"결과 저장: {output_path}")

import os
import cv2
import matplotlib.pyplot as plt
import random
from PIL import Image, ImageDraw, ImageFont
import numpy as np

# --- 1. 경로 설정 ---
FINAL_DATASET_IMAGES = './final_dataset/images/train'  # train 이미지 경로
FINAL_DATASET_LABELS = './final_dataset/labels/train'  # train 라벨 경로
CLASSES_PATH = './final_dataset/final_dataset.yaml'    # 클래스 이름 경로

# --- 2. 클래스 이름 로드 ---
class_names = []

if os.path.exists(CLASSES_PATH) and CLASSES_PATH.endswith('.yaml'):
    with open(CLASSES_PATH, 'r', encoding='utf-8') as f:
        lines = f.readlines()
        for line in lines:
            if line.strip().startswith('names:'):
                names_str = line.split('names:', 1)[1].strip()
                if names_str.startswith('[') and names_str.endswith(']'):
                    names_str = names_str[1:-1]
                    class_names = [name.strip().strip("'\"") for name in names_str.split(',')]
                break
elif os.path.exists('./yolo_dataset_complete/classes.txt'):
    with open('./yolo_dataset_complete/classes.txt', 'r', encoding='utf-8') as f:
        class_names = [line.strip() for line in f.readlines()]

print(f"클래스 이름 로드 완료: {len(class_names)}개")

# --- 3. 한글 폰트 설정 ---
def setup_korean_font():
    font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'
    if not os.path.exists(font_path):
        os.makedirs(os.path.dirname(font_path), exist_ok=True)
        print("폰트 다운로드 중...")
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf" 2> /dev/null || \
           wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf" 2> /dev/null

    try:
        font = ImageFont.truetype(font_path, 20)
        print(f"한글 폰트 로드 성공: {font_path}")
        return font
    except Exception as e:
        print(f"폰트 로드 실패: {e} → 기본 폰트 사용")
        return ImageFont.load_default()

font = setup_korean_font()

# --- 4. OpenCV 이미지에 한글 그리기 함수 ---
def put_text_korean(img, text, position, color):
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)
    draw.text(position, text, font=font, fill=color[::-1])
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

# --- 5. 이미지 목록 가져오기 ---
if not os.path.exists(FINAL_DATASET_IMAGES):
    raise FileNotFoundError(f"이미지 폴더 없음: {FINAL_DATASET_IMAGES}")

image_files = [f for f in os.listdir(FINAL_DATASET_IMAGES) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
print(f"총 {len(image_files)}개 이미지 발견")

# 랜덤으로 12개 선택 (샘플 수 조절 가능)
sample_size = min(12, len(image_files))
selected_images = random.sample(image_files, sample_size)

print(f"랜덤 선택된 이미지 {sample_size}개:")
for i, fname in enumerate(selected_images, 1):
    print(f"  {i}. {fname}")

# --- 6. 그리드 시각화 (3x4) ---
fig, axes = plt.subplots(3, 4, figsize=(20, 15))
axes = axes.flatten()

for idx, img_name in enumerate(selected_images):
    img_path = os.path.join(FINAL_DATASET_IMAGES, img_name)
    label_path = os.path.join(FINAL_DATASET_LABELS, os.path.splitext(img_name)[0] + ".txt")

    # 이미지 로드
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        continue

    img_vis = img.copy()
    h, w = img.shape[:2]

    # 라벨 파일 읽기
    if os.path.exists(label_path):
        with open(label_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            for line in lines:
                parts = line.strip().split()
                if len(parts) >= 5:
                    cls_id = int(parts[0])
                    x_center, y_center, box_w, box_h = map(float, parts[1:5])

                    # YOLO → 픽셀 좌표 변환
                    x1 = int((x_center - box_w / 2) * w)
                    y1 = int((y_center - box_h / 2) * h)
                    x2 = int((x_center + box_w / 2) * w)
                    y2 = int((y_center + box_h / 2) * h)

                    # 클래스 이름
                    label = class_names[cls_id] if cls_id < len(class_names) else f"Class {cls_id}"
                    text = f"{label}"

                    # 박스 그리기
                    cv2.rectangle(img_vis, (x1, y1), (x2, y2), (255, 0, 0), 3)

                    # 한글 텍스트
                    img_vis = put_text_korean(img_vis, text, (x1, y1 - 25), (255, 0, 0))

    # Matplotlib 출력
    axes[idx].imshow(cv2.cvtColor(img_vis, cv2.COLOR_BGR2RGB))
    axes[idx].set_title(img_name, fontsize=10, weight='bold')
    axes[idx].axis('off')

# 빈 서브플롯 숨기기
for idx in range(len(selected_images), len(axes)):
    axes[idx].axis('off')

plt.tight_layout()
plt.suptitle('final_dataset 이미지 샘플 (바운딩 박스 포함)', fontsize=16, weight='bold', y=1.02)
plt.show()

import os
import json
import cv2
import pandas as pd
from ultralytics import YOLO
from collections import defaultdict

# --- 설정 ---
MODEL_PATH = '/content/drive/MyDrive/코드잇/파트2/초급 프로젝트/모델/pill_detection_big_model_20250916_041533/best.pt'
IMAGE_DIR = './data/test_images'
ANNOTATION_BASE_DIR = './data/train_annotations'
OUTPUT_CSV = './submission_final.csv'

# --- 1. 모든 JSON 파일에서 category_name → category_id 매핑 생성 (공백 및 \xa0 제거 후 비교) ---
name_to_kaggle_id = {}

print("스캔 중: 모든 JSON 파일에서 category 매핑 추출 (공백 및 \\xa0 무시)...")
json_file_count = 0

for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_path = os.path.join(root, file)
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    if 'root' in data and isinstance(data['root'], dict):
                        data = data['root']

                    if 'categories' not in data or not isinstance(data.get('categories'), list):
                        continue

                    for cat in data.get('categories', []):
                        if isinstance(cat, dict) and 'name' in cat and 'id' in cat:
                            name = cat.get('name')
                            kaggle_id = cat.get('id')
                            # 모든 공백 및 \xa0 제거 후 저장
                            cleaned_name = name.replace(" ", "").replace('\xa0', '')
                            if cleaned_name in name_to_kaggle_id and name_to_kaggle_id[cleaned_name] != kaggle_id:
                                print(f"[경고] 공백 및 \\xa0 제거 후 클래스 이름 중복: {name} → 기존: {name_to_kaggle_id[cleaned_name]}, 신규: {kaggle_id}")
                            name_to_kaggle_id[cleaned_name] = kaggle_id

                json_file_count += 1
            except Exception as e:
                continue

print(f"총 {json_file_count}개 JSON 파일 스캔 완료")
print(f"매핑된 고유 클래스 수: {len(name_to_kaggle_id)}")
print("\n어노테이션 기반 (공백/\\xa0 제거) 이름 → Kaggle ID 매핑 샘플:")
# Print first 10 items of the name_to_kaggle_id map
for i, (name, kaggle_id) in enumerate(name_to_kaggle_id.items()):
    if i >= 10: break
    print(f"- '{name}': {kaggle_id}")


# --- 2. YOLO 클래스 이름 로드 (공백 제거 후 비교) ---
yolo_classes_path = './yolo_dataset/classes.txt'
if not os.path.exists(yolo_classes_path):
    raise FileNotFoundError(f"YOLO 클래스 파일 없음: {yolo_classes_path}")

yolo_id_to_name = []
with open(yolo_classes_path, 'r', encoding='utf-8') as f:
    for line in f:
        class_name = line.strip()
        yolo_id_to_name.append(class_name.replace(" ", "").replace('\xa0', '')) # 모든 공백 및 \xa0 제거 후 리스트에 추가

print(f"\nYOLO 클래스 수: {len(yolo_id_to_name)}")


# --- 3. YOLO ID → Kaggle category_id 매핑 (공백 제거된 이름 사용) ---
yolo_to_kaggle = {}
# Iterate through yolo_id_to_name using index for yolo_id
print("\nYOLO ID → Kaggle category_id 매핑 과정:")
for yolo_id, class_name_cleaned in enumerate(yolo_id_to_name):
    if class_name_cleaned in name_to_kaggle_id:
        kaggle_id = name_to_kaggle_id[class_name_cleaned]
        yolo_to_kaggle[yolo_id] = kaggle_id
        # print(f"  Mapped YOLO ID {yolo_id} ('{class_name_cleaned}') to Kaggle ID {kaggle_id}") # Optional: print all mappings
    else:
        # Use original class name from classes.txt for warning message if needed
        original_class_name = open(yolo_classes_path, 'r', encoding='utf-8').readlines()[yolo_id].strip()
        print(f"[경고] 매핑 실패: YOLO 클래스 '{original_class_name}' (공백 및 \\xa0 제거: '{class_name_cleaned}') → Kaggle ID 없음")

print(f"\nYOLO ID → Kaggle category_id 매핑 완료. 매핑된 항목 수: {len(yolo_to_kaggle)}")
print("YOLO ID → Kaggle category_id 매핑 샘플:")
# Print first 10 items of the yolo_to_kaggle map
for i, (yolo_id, kaggle_id) in enumerate(yolo_to_kaggle.items()):
     if i >= 10: break
     print(f"- YOLO ID {yolo_id} → Kaggle ID {kaggle_id}")


# --- 4. 이미지 파일 목록 + image_id 매핑 (확장자 제거 및 숫자 정렬) ---
image_files = [
    f for f in os.listdir(IMAGE_DIR)
    if f.lower().endswith(('.png', '.jpg', '.jpeg'))
]

# Sort numerically based on filename without extension
image_files.sort(key=lambda f: int(os.path.splitext(f)[0]))

# 파일명에서 확장자 제거 후 image_id로 사용
image_name_to_id = {name: os.path.splitext(name)[0] for name in image_files}
print(f"\n총 {len(image_files)}개 테스트 이미지")

# 상위 10개 이미지 ID (확장자 제거 및 숫자 정렬) 출력
print("\n상위 10개 테스트 이미지 ID (확장자 제거 및 숫자 정렬):")
for i, img_name in enumerate(image_files[:10]):
    print(f"- {image_name_to_id[img_name]}")


# --- 5. 모델 로드 ---
model = YOLO(MODEL_PATH)

# --- 6. 예측 + CSV 생성 ---
results_list = []
annotation_id = 1

for img_name in image_files:
    img_path = os.path.join(IMAGE_DIR, img_name)
    if not os.path.exists(img_path):
        continue

    img = cv2.imread(img_path)
    if img is None:
        continue

    # 예측 (NMS 강화)
    results = model.predict(
        img_path,
        conf=0.3,
        iou=0.5,
        verbose=False
    )

    image_id = image_name_to_id[img_name]  # ✅ 확장자 제거된 파일 이름 사용

    for result in results:
        boxes = result.boxes
        for box in boxes:
            xyxy = box.xyxy.cpu().numpy().flatten()
            conf = float(box.conf.cpu().numpy())
            yolo_cls_id = int(box.cls.cpu().numpy())

            if len(xyxy) != 4:
                continue

            if yolo_cls_id not in yolo_to_kaggle:
                # This should ideally not happen if all classes are mapped
                print(f"[경고] YOLO ID {yolo_cls_id} for image {img_name} not found in yolo_to_kaggle mapping.")
                continue

            category_id = yolo_to_kaggle[yolo_cls_id]  # ✅ 고유 약품 ID
            x1, y1, x2, y2 = map(float, xyxy)
            bbox_x, bbox_y = x1, y1
            bbox_w, bbox_h = x2 - x1, y2 - y1

            results_list.append({
                'annotation_id': annotation_id,
                'image_id': image_id,
                'category_id': category_id,
                'bbox_x': bbox_x,
                'bbox_y': bbox_y,
                'bbox_w': bbox_w,
                'bbox_h': bbox_h,
                'score': round(conf, 2) # Format confidence to 2 decimal places
            })
            annotation_id += 1

# --- 7. 저장 ---
df = pd.DataFrame(results_list, columns=[
    'annotation_id', 'image_id', 'category_id',
    'bbox_x', 'bbox_y', 'bbox_w', 'bbox_h', 'score'
])

df.to_csv(OUTPUT_CSV, index=False, encoding='utf-8')
print(f"\n✅ 최종 제출 파일 저장 완료: {OUTPUT_CSV}")
print(f"총 {len(df)}개 예측 박스 저장됨")

# --- 8. 샘플 출력 ---
print("\n--- 샘플 결과 ---")
print(df.head(10))

import os
import pandas as pd
import cv2
import matplotlib.pyplot as plt
import random
from PIL import Image, ImageDraw, ImageFont
import numpy as np

# --- 설정 ---
SUBMISSION_CSV_PATH = './submission_final.csv' # 생성된 CSV 파일 경로
TEST_IMAGE_DIR = './data/test_images'
CLASSES_PATH = './yolo_dataset/classes.txt' # YOLO 클래스 파일 경로

# --- 1. 제출 데이터 로드 ---
if not os.path.exists(SUBMISSION_CSV_PATH):
    raise FileNotFoundError(f"제출 CSV 파일 없음: {SUBMISSION_CSV_PATH}")

submission_df = pd.read_csv(SUBMISSION_CSV_PATH)
print(f"제출 CSV 파일 로드 완료: {len(submission_df)}개 예측 박스")

# 파일명 (확장자 제외) → 전체 파일명 매핑 (CSV의 image_id와 일치하도록)
image_files = [
    f for f in os.listdir(TEST_IMAGE_DIR)
    if f.lower().endswith(('.png', '.jpg', '.jpeg'))
]
# Sort numerically based on filename without extension
image_files.sort(key=lambda f: int(os.path.splitext(f)[0]))

# Modified: Use filename without extension as key, full filename as value
image_id_to_name_map = {os.path.splitext(name)[0]: name for name in image_files}


# --- 2. 클래스 이름 로드 ---
class_names = []
if os.path.exists(CLASSES_PATH):
    with open(CLASSES_PATH, 'r', encoding='utf-8') as f:
        class_names = [line.strip() for line in f.readlines()]
    print(f"클래스 이름 로드 완료: {len(class_names)}개")
else:
    print(f"[경고] 클래스 파일 없음: {CLASSES_PATH}. 클래스 ID만 표시됩니다.")


# --- 3. 한글 폰트 설정 (PIL용) ---
def setup_korean_font():
    """안정적인 한글 폰트 설정"""
    font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'

    # 폰트 파일 없으면 자동 다운로드
    if not os.path.exists(font_path):
        os.makedirs(os.path.dirname(font_path), exist_ok=True)
        print("폰트 다운로드 중...")
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf" 2> /dev/null || \
           wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf" 2> /dev/null

    # 폰트 로드 시도
    try:
        font = ImageFont.truetype(font_path, 20)
        print(f"한글 폰트 로드 성공: {font_path}")
        return font
    except Exception as e:
        print(f"폰트 로드 실패: {e} → 기본 폰트 사용")
        return ImageFont.load_default()

# 폰트 설정
font = setup_korean_font()

# --- 4. OpenCV 이미지에 한글 그리기 함수 ---
def put_text_korean(img, text, position, color):
    """
    OpenCV 이미지에 한글 텍스트 그리기 (PIL 사용)
    """
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)
    # PIL draw.text는 (x, y)가 좌상단
    draw.text(position, text, font=font, fill=color[::-1])  # OpenCV BGR -> PIL RGB
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)


# --- 5. 시각화 함수 ---
def visualize_predictions_from_csv(image_id_from_csv, predictions_df, image_dir, class_names, font, image_id_to_name_map):
    """
    테스트 이미지에 CSV 예측 결과를 시각화합니다.
    """
    # Ensure image_id_from_csv is a string and strip whitespace before lookup
    image_id_str = str(image_id_from_csv).strip()

    # Get the full image name from the image_id
    image_name = image_id_to_name_map.get(image_id_str) # Use the cleaned string for lookup
    if image_name is None:
        print(f"Image file not found for image_id: {image_id_from_csv}")
        return None

    img_path = os.path.join(image_dir, image_name)
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        return None

    img_vis = img.copy()
    h, w = img.shape[:2]

    # 해당 이미지의 예측 결과 필터링
    image_predictions = predictions_df[predictions_df['image_id'] == image_id_from_csv]

    print(f"  - {image_name}: {len(image_predictions)}개 예측 박스 시각화")

    for idx, row in image_predictions.iterrows():
        category_id = row['category_id']
        bbox_x = row['bbox_x']
        bbox_y = row['bbox_y']
        bbox_w = row['bbox_w']
        bbox_h = row['bbox_h']
        score = row['score']

        # CSV의 bbox (x, y, w, h)는 픽셀 좌표 기준이라고 가정
        x1, y1 = int(bbox_x), int(bbox_y)
        x2, y2 = int(bbox_x + bbox_w), int(bbox_y + bbox_h)

        try:
             label_text = f"ID:{category_id} ({score:.2f})"
        except Exception as e:
             label_text = f"ID:{category_id} ({score:.2f})"


        # 좌표 유효성 검사
        if x1 < 0 or y1 < 0 or x2 > w or y2 > h:
             print(f"  [경고] 박스 좌표가 이미지 범위를 벗어남 ({x1}, {y1}, {x2}, {y2}) for {image_name}")
             continue # 범위를 벗어나는 박스는 그리지 않음


        # 박스 그리기
        color = (0, 255, 0) # 초록색
        cv2.rectangle(img_vis, (x1, y1), (x2, y2), color, 3)

        # 텍스트 위치 (박스 상단)
        text_position = (x1, y1 - 25)
        if text_position[1] < 0: # 이미지를 벗어나면 박스 내부 하단으로
             text_position = (x1, y2 + 5) # y2 + 5 픽셀 아래

        img_vis = put_text_korean(img_vis, label_text, text_position, color)


    return img_vis

# --- 6. 샘플 이미지 선택 및 시각화 ---
if not os.path.exists(TEST_IMAGE_DIR):
    raise FileNotFoundError(f"테스트 이미지 폴더 없음: {TEST_IMAGE_DIR}")

# Get the list of image_ids from the submission CSV
test_image_ids_from_csv = submission_df['image_id'].unique().tolist()


if len(test_image_ids_from_csv) == 0:
    print("제출 CSV에 테스트 이미지 ID가 없습니다.")
else:
    # 랜덤으로 12개 선택 (샘플 수 조절 가능)
    sample_size = min(10, len(test_image_ids_from_csv))
    selected_image_ids = random.sample(test_image_ids_from_csv, sample_size)

    print(f"\n랜덤 선택된 테스트 이미지 {sample_size}개에 대해 CSV 예측 결과 시각화:")

    # 그리드 시각화 (2x5) 설정
    fig, axes = plt.subplots(2, 5, figsize=(20, 10)) # Adjusted for 10 images
    axes = axes.flatten()

    for idx, img_id in enumerate(selected_image_ids): # Iterate through selected image_ids
        img_with_predictions = visualize_predictions_from_csv(
            img_id, # Pass the image_id from CSV
            submission_df,
            TEST_IMAGE_DIR,
            class_names,
            font,
            image_id_to_name_map # Pass the mapping dictionary
        )

        if img_with_predictions is not None:
            # Matplotlib 출력
            axes[idx].imshow(cv2.cvtColor(img_with_predictions, cv2.COLOR_BGR2RGB))
            axes[idx].set_title(image_id_to_name_map.get(str(img_id).strip(), str(img_id).strip()), fontsize=10, weight='bold') # Use filename as title
            axes[idx].axis('off')
        else:
            # 이미지 로드 실패 시 해당 서브플롯 비활성화
            axes[idx].set_title(f"Error loading {img_id}", fontsize=10, color='red')
            axes[idx].axis('off')


    # 빈 서브플롯 숨기기
    for idx in range(len(selected_image_ids), len(axes)):
        axes[idx].axis('off')

    plt.tight_layout()
    plt.suptitle('Submission CSV 예측 결과 시각화 (랜덤 샘플)', fontsize=16, weight='bold', y=1.02)
    plt.show()

print("\n시각화 완료. 이미지에 그려진 박스와 라벨을 확인하여 예측이 올바른지 검증하세요.")

import os
import cv2
import matplotlib.pyplot as plt
from ultralytics import YOLO
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import json # Import json for loading annotations

# --- 1. 설정 ---
MODEL_PATH = '/content/drive/MyDrive/코드잇/파트2/초급 프로젝트/모델/pill_detection_big_model_20250916_041533/best.pt'  # 학습된 모델 경로
TEST_IMAGE_DIR = './data/test_images'
TARGET_IMAGE_NAME = '1.png' # 시각화할 특정 이미지 파일 이름
ANNOTATION_BASE_DIR = './data/train_annotations' # Added for mapping regeneration

# --- 2. 모델 로드 ---
model = YOLO(MODEL_PATH)
print(f"모델 로드 완료: {MODEL_PATH}")

# --- 3. 클래스 이름 로드 및 Kaggle ID 매핑 생성 ---
# Regenerate Kaggle ID to Class Name map from annotations for consistent labeling
kaggle_id_to_name = {}

print("스캔 중: 모든 JSON 파일에서 Kaggle ID → Class Name 매핑 추출...")
json_file_count = 0

if os.path.exists(ANNOTATION_BASE_DIR):
    for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
        for file in files:
            if file.endswith('.json'):
                json_path = os.path.join(root, file)
                try:
                    with open(json_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        if 'root' in data and isinstance(data['root'], dict):
                            data = data['root']

                        if 'categories' not in data or not isinstance(data.get('categories'), list):
                            continue

                        for cat in data.get('categories', []):
                            if isinstance(cat, dict) and 'name' in cat and 'id' in cat:
                                name = cat.get('name')
                                kaggle_id = cat.get('id')
                                # Use original name for display
                                kaggle_id_to_name[kaggle_id] = name

                    json_file_count += 1
                except Exception as e:
                    # print(f"Error parsing {json_path} for mapping: {e}") # Optional: print parsing errors
                    pass # Silently skip files that cause parsing errors

    print(f"총 {json_file_count}개 JSON 파일 스캔 완료")
    print(f"Regenerated Kaggle ID to Name map with {len(kaggle_id_to_name)} entries.")
else:
    print(f"[경고] Annotation directory not found at {ANNOTATION_BASE_DIR}. Cannot regenerate Kaggle ID to Name mapping. Will use model.names (YOLO IDs).")
    # Fallback to model.names if annotation directory is not found
    try:
        # Attempt to build a map from YOLO ID to name using model.names
        # This assumes YOLO model's internal names are correct, but might not match Kaggle IDs directly
        kaggle_id_to_name = {i: name for i, name in enumerate(model.names)}
        print(f"Using model.names for class names (YOLO IDs).")
    except Exception as e:
        print(f"[오류] Could not load class names from model.names: {e}. Class ID will be displayed.")
        # Fallback to displaying class ID if model.names is not accessible
        kaggle_id_to_name = {} # Empty map, will result in displaying ID


# --- 4. 한글 폰트 설정 (PIL용) ---
def setup_korean_font():
    """안정적인 한글 폰트 설정"""
    font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'

    # 폰트 파일 없으면 자동 다운로드
    if not os.path.exists(font_path):
        os.makedirs(os.path.dirname(font_path), exist_ok=True)
        print("폰트 다운로드 중...")
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf" 2> /dev/null || \
           wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf" 2> /dev_null

    # 폰트 로드 시도
    try:
        font = ImageFont.truetype(font_path, 20)
        print(f"한글 폰트 로드 성공: {font_path}")
        return font
    except Exception as e:
        print(f"폰트 로드 실패: {e} → 기본 폰트 사용")
        return ImageFont.load_default()

# 폰트 설정
font = setup_korean_font()

# --- 5. OpenCV 이미지에 한글 그리기 함수 ---
def put_text_korean(img, text, position, color):
    """
    OpenCV 이미지에 한글 텍스트 그리기 (PIL 사용)
    """
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)
    # PIL draw.text는 (x, y)가 좌상단
    draw.text(position, text, font=font, fill=color[::-1])  # OpenCV BGR -> PIL RGB
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)


# --- 6. 특정 이미지에 대해 예측 + 시각화 ---
img_path = os.path.join(TEST_IMAGE_DIR, TARGET_IMAGE_NAME)

if not os.path.exists(img_path):
    print(f"오류: 대상 이미지 파일이 없습니다: {img_path}")
else:
    print(f"'{TARGET_IMAGE_NAME}' 이미지에 대해 예측 및 시각화 시작...")

    # 이미지 로드
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
    else:
        # 예측 수행
        # conf=0.3은 예시, 필요에 따라 조정하세요.
        results = model.predict(img_path, conf=0.3, iou=0.5, verbose=False)

        # 시각화용 이미지 복사
        img_vis = img.copy()
        h, w = img.shape[:2]

        detection_count = 0
        if results and len(results) > 0:
            # 결과 객체에서 바로 박스 정보를 가져와서 그립니다.
            for box in results[0].boxes: # assuming batch size is 1 for single image prediction
                # 좌표 추출 (안전한 방식)
                xyxy = box.xyxy.cpu().numpy().flatten()
                if len(xyxy) != 4:
                    print(f"잘못된 좌표 형식: {xyxy}")
                    continue

                x1, y1, x2, y2 = map(int, xyxy)
                conf = float(box.conf.cpu().numpy())
                yolo_cls_id = int(box.cls.cpu().numpy()) # This is YOLO's internal class ID


                # Get Kaggle category_id corresponding to YOLO class ID if yolo_to_kaggle map is available
                # Since yolo_to_kaggle was generated in another cell, we need to rely on the
                # regenerated kaggle_id_to_name map and the YOLO class ID.
                # This requires an assumption: model.names[yolo_cls_id] corresponds to a name
                # that can be found in the annotation JSONs to get the Kaggle ID.
                # A more robust way is to use the yolo_to_kaggle map if it was saved/loaded.
                # For simplicity here, let's try to get the name from the regenerated map
                # using the YOLO class ID as a potential key if model.names was used as fallback,
                # OR by finding the name in the map that corresponds to model.names[yolo_cls_id].

                # Attempt to get the class name using the regenerated kaggle_id_to_name map
                # We need the Kaggle ID for this lookup. The model prediction gives YOLO_cls_id.
                # We need the mapping from YOLO_cls_id to Kaggle ID.
                # If the regenerated kaggle_id_to_name map uses Kaggle IDs as keys,
                # we need to find the Kaggle ID that corresponds to the YOLO_cls_id.

                # Let's assume for now that model.names[yolo_cls_id] gives the name,
                # and we can find the corresponding Kaggle ID from the regenerated map.
                # Or, more directly, if the regenerated map has YOLO_cls_id as keys (unlikely based on JSON structure),
                # or if there's a direct YOLO_cls_id to Kaggle_id map.

                # Simpler approach: If kaggle_id_to_name was regenerated from JSONs,
                # its keys are Kaggle IDs. We need to find the Kaggle ID for this detection.
                # The model provides YOLO_cls_id. We need the yolo_to_kaggle map.
                # Since we don't have yolo_to_kaggle here, let's modify the regeneration
                # to build a map from YOLO_name (cleaned) to Kaggle ID.

                # Re-regenerate name_to_kaggle_id (cleaned name as key, Kaggle ID as value)
                name_to_kaggle_id_cleaned = {}
                if os.path.exists(ANNOTATION_BASE_DIR):
                     for root_m, dirs_m, files_m in os.walk(ANNOTATION_BASE_DIR):
                        for file_m in files_m:
                            if file_m.endswith('.json'):
                                json_path_m = os.path.join(root_m, file_m)
                                try:
                                    with open(json_path_m, 'r', encoding='utf-8') as f_m:
                                        data_m = json.load(f_m)
                                        if 'root' in data_m and isinstance(data_m['root'], dict):
                                            data_m = data_m['root']
                                        if 'categories' in data_m and isinstance(data_m.get('categories'), list):
                                            for cat_m in data_m.get('categories', []):
                                                if isinstance(cat_m, dict) and 'name' in cat_m and 'id' in cat_m:
                                                    name_m = cat_m.get('name')
                                                    kaggle_id_m = cat_m.get('id')
                                                    cleaned_name_m = name_m.replace(" ", "").replace('\xa0', '')
                                                    name_to_kaggle_id_cleaned[cleaned_name_m] = kaggle_id_m
                                except Exception as e_m:
                                    pass # Skip parsing errors

                # Get the YOLO class name from model.names
                yolo_class_name = model.names[yolo_cls_id] if yolo_cls_id < len(model.names) else f"Class {yolo_cls_id}"
                cleaned_yolo_class_name = yolo_class_name.replace(" ", "").replace('\xa0', '')

                # Find the corresponding Kaggle ID using the cleaned name
                kaggle_category_id = name_to_kaggle_id_cleaned.get(cleaned_yolo_class_name, None)

                # Get the class name for display using the Kaggle ID
                # If Kaggle ID is found, use the name from the regenerated map (which has Kaggle IDs as keys)
                # If Kaggle ID is not found, or if kaggle_id_to_name map was not regenerated, use the YOLO class name
                if kaggle_category_id is not None and kaggle_category_id in kaggle_id_to_name:
                     label = kaggle_id_to_name[kaggle_category_id]
                else:
                     # Fallback: use the YOLO class name if Kaggle mapping fails
                     label = yolo_class_name
                     if kaggle_category_id is None:
                         print(f"[경고] YOLO class '{yolo_class_name}' (cleaned: '{cleaned_yolo_class_name}') did not map to a Kaggle ID.")
                     elif kaggle_category_id not in kaggle_id_to_name:
                          print(f"[경고] Kaggle ID {kaggle_category_id} found for YOLO class '{yolo_class_name}' but not in kaggle_id_to_name map.")


                text = f"{label} ({conf:.2f})"

                # 좌표 유효성 검사
                if x1 < 0 or y1 < 0 or x2 > img_vis.shape[1] or y2 > img_vis.shape[0]:
                    print(f"  [경고] 박스 좌표가 이미지 범위를 벗어남 ({x1}, {y1}, {x2}, {y2})")
                    continue

                # 박스 그리기
                color = (0, 255, 0) # 초록색
                cv2.rectangle(img_vis, (x1, y1), (x2, y2), color, 3)
                # print(f"박스 그림: {label} at ({x1}, {y1}, {x2}, {y2}) with conf {conf:.2f}") # Optional: print details

                # 한글 텍스트 그리기
                text_position = (x1, y1 - 25)
                if text_position[1] < 0:
                     text_position = (x1, y2 + 5)
                img_vis = put_text_korean(img_vis, text, text_position, color)

                detection_count += 1

        print(f"탐지된 객체 수: {detection_count}")

        # Matplotlib로 시각화
        plt.figure(figsize=(12, 8))
        plt.imshow(cv2.cvtColor(img_vis, cv2.COLOR_BGR2RGB))
        plt.title(f"모델 예측 결과: {TARGET_IMAGE_NAME}", fontsize=14, weight='bold')
        plt.axis('off')
        plt.tight_layout()
        plt.show()

        # 결과 이미지 저장 (선택 사항)
        # OUTPUT_VIS_DIR = './test_results_visualized_model' # 시각화 결과 저장 폴더
        # os.makedirs(OUTPUT_VIS_DIR, exist_ok=True)
        # output_path = os.path.join(OUTPUT_VIS_DIR, TARGET_IMAGE_NAME)
        # cv2.imwrite(output_path, img_vis)
        # print(f"결과 저장 (선택 사항): {output_path}")


print("\n모델 예측 시각화 완료. 이미지에 그려진 박스와 라벨을 확인하여 예측이 올바른지 검증하세요.")

import os
import pandas as pd
import cv2
import matplotlib.pyplot as plt
import random # Keep import for potential future use, but won't be used in this specific visualization
from PIL import Image, ImageDraw, ImageFont
import numpy as np

# --- 설정 ---
SUBMISSION_CSV_PATH = './submission_final.csv' # 생성된 CSV 파일 경로
TEST_IMAGE_DIR = './data/test_images'
CLASSES_PATH = './yolo_dataset/classes.txt' # YOLO 클래스 파일 경로
TARGET_IMAGE_NAME = '1.png' # Specify the target image for detailed inspection

# Placeholder for Kaggle ID to Class Name mapping
kaggle_id_to_name = {}

yolo_id_to_name_list = []
if os.path.exists(CLASSES_PATH):
    with open(CLASSES_PATH, 'r', encoding='utf-8') as f:
        yolo_id_to_name_list = [line.strip() for line in f.readlines()]
    print(f"YOLO Class names loaded from {CLASSES_PATH}: {len(yolo_id_to_name_list)}개")

    ANNOTATION_BASE_DIR_VIS = './data/train_annotations' # Ensure this path is correct
    if os.path.exists(ANNOTATION_BASE_DIR_VIS):
        print("Regenerating Kaggle ID to Class Name mapping from annotations...")
        temp_name_to_kaggle_id = {}
        temp_kaggle_id_to_name = {} # This is the map we want

        json_file_count = 0
        for root, dirs, files in os.walk(ANNOTATION_BASE_DIR_VIS):
            for file in files:
                if file.endswith('.json'):
                    json_path = os.path.join(root, file)
                    try:
                        with open(json_path, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                            if 'root' in data and isinstance(data['root'], dict):
                                data = data['root']

                            if 'categories' not in data or not isinstance(data.get('categories'), list):
                                continue

                            for cat in data.get('categories', []):
                                if isinstance(cat, dict) and 'name' in cat and 'id' in cat:
                                    name = cat.get('name')
                                    kaggle_id = cat.get('id')
                                    # Use original name for display, map from kaggle_id
                                    temp_kaggle_id_to_name[kaggle_id] = name
                                    # Also build the cleaned name map for robustness
                                    cleaned_name = name.replace(" ", "").replace('\xa0', '')
                                    temp_name_to_kaggle_id[cleaned_name] = kaggle_id

                        json_file_count += 1
                    except Exception as e:
                        # print(f"Error parsing {json_path} for mapping: {e}") # Optional: print parsing errors
                        pass # Silently skip files that cause parsing errors

        kaggle_id_to_name = temp_kaggle_id_to_name
        print(f"Regenerated Kaggle ID to Name map with {len(kaggle_id_to_name)} entries.")
    else:
        print(f"[경고] Annotation directory not found at {ANNOTATION_BASE_DIR_VIS}. Cannot regenerate Kaggle ID to Name mapping. Will display Category ID.")


# --- 1. 제출 데이터 로드 ---
if not os.path.exists(SUBMISSION_CSV_PATH):
    raise FileNotFoundError(f"제출 CSV 파일 없음: {SUBMISSION_CSV_PATH}")

# Ensure image_id is read as string to avoid type mismatches during comparison
submission_df = pd.read_csv(SUBMISSION_CSV_PATH, dtype={'image_id': str})
print(f"제출 CSV 파일 로드 완료: {len(submission_df)}개 예측 박스")
# Display the first few rows and dtypes for inspection
print("\nSubmission CSV head:")
display(submission_df.head())
print("\nSubmission CSV dtypes:")
print(submission_df.dtypes)


# 파일명 (확장자 제외) → 전체 파일명 매핑 (CSV의 image_id와 일치하도록)
image_files = [
    f for f in os.listdir(TEST_IMAGE_DIR)
    if f.lower().endswith(('.png', '.jpg', '.jpeg'))
]
# Sort numerically based on filename without extension
image_files.sort(key=lambda f: int(os.path.splitext(f)[0]))

# Modified: Use filename without extension as key, full filename as value
image_id_to_name_map = {os.path.splitext(name)[0]: name for name in image_files}
print(f"\nTest images found in directory: {len(image_files)}개")
print("\nFirst 10 entries in image_id_to_name_map:")
# Print first 10 items in the map for inspection
for i, (key, value) in enumerate(image_id_to_name_map.items()):
    if i >= 10: break
    print(f"- '{key}': '{value}'")


# --- 2. 클래스 이름 로드 (YOLO names - fallback if Kaggle map fails) ---
# Keep this for potential fallback or other uses, but prefer kaggle_id_to_name for labels
yolo_class_names = []
if os.path.exists(CLASSES_PATH):
    with open(CLASSES_PATH, 'r', encoding='utf-8') as f:
        yolo_class_names = [line.strip() for line in f.readlines()]
    # print(f"YOLO 클래스 이름 로드 완료: {len(yolo_class_names)}개") # Suppress this print to avoid confusion


# --- 3. 한글 폰트 설정 (PIL용) ---
def setup_korean_font():
    """안정적인 한글 폰트 설정"""
    font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'

    # 폰트 파일 없으면 자동 다운로드
    if not os.path.exists(font_path):
        os.makedirs(os.path.dirname(font_path), exist_ok=True)
        print("폰트 다운로드 중...")
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf" 2> /dev/null || \
           wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf" 2> /dev/null

    # 폰트 로드 시도
    try:
        font = ImageFont.truetype(font_path, 20)
        print(f"한글 폰트 로드 성공: {font_path}")
        return font
    except Exception as e:
        print(f"폰트 로드 실패: {e} → 기본 폰트 사용")
        return ImageFont.load_default()

# 폰트 설정
font = setup_korean_font()

# --- 4. OpenCV 이미지에 한글 그리기 함수 ---
def put_text_korean(img, text, position, color):
    """
    OpenCV 이미지에 한글 텍스트 그리기 (PIL 사용)
    """
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)
    # PIL draw.text는 (x, y)가 좌상단
    draw.text(position, text, font=font, fill=color[::-1])  # OpenCV BGR -> PIL RGB
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)


# --- 5. 시각화 함수 ---
def visualize_predictions_from_csv(image_id_from_csv, predictions_df, image_dir, kaggle_id_to_name_map, font, image_id_to_name_map_filepath):
    """
    테스트 이미지에 CSV 예측 결과를 시각화합니다.
    """
    # Ensure image_id_from_csv is a string and strip whitespace before lookup
    image_id_str = str(image_id_from_csv).strip()

    # Get the full image name from the image_id map generated from file list
    image_name = image_id_to_name_map_filepath.get(image_id_str) # Use the cleaned string for lookup
    if image_name is None:
        print(f"Image file not found in directory for image_id: {image_id_from_csv}")
        return None

    img_path = os.path.join(image_dir, image_name)
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        return None

    img_vis = img.copy()
    h, w = img.shape[:2]

    # Filter predictions using the stripped image_id string for robustness
    # Explicitly convert submission_df['image_id'] to string and strip for comparison
    image_predictions = predictions_df[predictions_df['image_id'].astype(str).str.strip() == image_id_str]

    print(f"  - {image_name}: {len(image_predictions)}개 예측 박스 시각화")
    # Add print to show the filtered predictions
    if not image_predictions.empty:
        print(f"  Filtered predictions for image_id '{image_id_str}':")
        display(image_predictions.head())
    else:
        print(f"  No predictions found in CSV for image_id '{image_id_str}'.")


    for idx, row in image_predictions.iterrows():
        category_id = row['category_id']
        bbox_x = row['bbox_x']
        bbox_y = row['bbox_y']
        bbox_w = row['bbox_w']
        bbox_h = row['bbox_h']
        score = row['score']

        # CSV의 bbox (x, y, w, h)는 픽셀 좌표 기준이라고 가정
        x1, y1 = int(bbox_x), int(bbox_y)
        x2, y2 = int(bbox_x + bbox_w), int(bbox_y + bbox_h)

        # Get class name from Kaggle ID mapping
        class_name = kaggle_id_to_name_map.get(category_id, f"Unknown ID:{category_id}")
        label_text = f"{class_name} ({score:.2f})"


        # 좌표 유효성 검사
        if x1 < 0 or y1 < 0 or x2 > w or y2 > h:
             print(f"  [경고] 박스 좌표가 이미지 범위를 벗어남 ({x1}, {y1}, {x2}, {y2}) for {image_name}")
             continue # 범위를 벗어나는 박스는 그리지 않음


        # 박스 그리기
        color = (0, 255, 0) # 초록색
        cv2.rectangle(img_vis, (x1, y1), (x2, y2), color, 3)

        # 텍스트 위치 (박스 상단)
        text_position = (x1, y1 - 25)
        if text_position[1] < 0: # 이미지를 벗어나면 박스 내부 하단으로
             text_position = (x1, y2 + 5) # y2 + 5 픽셀 아래

        img_vis = put_text_korean(img_vis, label_text, text_position, color)


    return img_vis

# --- 6. 特定 이미지 선택 및 시각화 (CSV 기반) ---
print(f"\n'{TARGET_IMAGE_NAME}' 이미지에 대해 CSV 예측 결과 시각화:")

# Get the image_id for the target image (filename without extension)
target_image_id = os.path.splitext(TARGET_IMAGE_NAME)[0]

# Add a print to check the target_image_id and its type
print(f"Target image ID (from filename): '{target_image_id}', Type: {type(target_image_id)}")

# Add a print to check if the target_image_id exists in the CSV's image_id column
csv_image_ids = submission_df['image_id'].unique().tolist()
print(f"Image IDs found in CSV (first 10): {csv_image_ids[:10]}")
print(f"Is target image ID '{target_image_id}' in CSV image_ids? {target_image_id in csv_image_ids}")


img_with_predictions = visualize_predictions_from_csv(
    target_image_id, # Pass the target image_id (filename without extension)
    submission_df,
    TEST_IMAGE_DIR,
    kaggle_id_to_name, # Pass the Kaggle ID to Name map
    font,
    image_id_to_name_map # Pass the image_id_to_name_map_filepath
)

if img_with_predictions is not None:
    # Matplotlib 출력
    plt.figure(figsize=(12, 8))
    plt.imshow(cv2.cvtColor(img_with_predictions, cv2.COLOR_BGR2RGB))
    # Use the image_id to get the filename for the title
    title_filename = image_id_to_name_map.get(str(target_image_id).strip(), str(target_image_id).strip())
    plt.title(f'Submission CSV 예측 결과: {title_filename}', fontsize=16, weight='bold')
    plt.axis('off')
    plt.tight_layout()
    plt.show()
else:
    print(f"'{TARGET_IMAGE_NAME}' 이미지에 대한 시각화 실패.")


print("\n시각화 완료. 이미지에 그려진 박스와 라벨을 확인하여 예측이 올바른지 검증하세요.")

import os
import json
import pandas as pd
from collections import defaultdict

# --- 설정 ---
YOLO_CLASSES_PATH = './yolo_dataset/classes.txt'
ANNOTATION_BASE_DIR = './data/train_annotations'
OUTPUT_CSV = './pill.csv'

# --- 1. YOLO 클래스 이름 로드 ---
yolo_class_names = []
if os.path.exists(YOLO_CLASSES_PATH):
    with open(YOLO_CLASSES_PATH, 'r', encoding='utf-8') as f:
        yolo_class_names = [line.strip() for line in f.readlines()]
    print(f"YOLO 클래스 이름 로드 완료: {len(yolo_class_names)}개")
else:
    raise FileNotFoundError(f"YOLO 클래스 파일 없음: {YOLO_CLASSES_PATH}")

# --- 2. 어노테이션 JSON 파일에서 클래스 이름 → Kaggle ID 매핑 생성 (공백 및 \xa0 제거 후 비교) ---
# Using defaultdict to handle potential multiple JSONs for the same class name, taking the first encountered ID
name_to_kaggle_id_cleaned = {}

print("스캔 중: 어노테이션 JSON 파일에서 클래스 이름 → Kaggle ID 매핑 추출 (공백 및 \\xa0 무시)...")
json_file_count = 0

if os.path.exists(ANNOTATION_BASE_DIR):
    for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
        for file in files:
            if file.endswith('.json'):
                json_path = os.path.join(root, file)
                try:
                    with open(json_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        if 'root' in data and isinstance(data['root'], dict):
                            data = data['root']

                        if 'categories' not in data or not isinstance(data.get('categories'), list):
                            continue

                        for cat in data.get('categories', []):
                            if isinstance(cat, dict) and 'name' in cat and 'id' in cat:
                                name = cat.get('name')
                                kaggle_id = cat.get('id')
                                # 모든 공백 및 \xa0 제거 후 저장
                                cleaned_name = name.replace(" ", "").replace('\xa0', '')
                                if cleaned_name not in name_to_kaggle_id_cleaned:
                                     name_to_kaggle_id_cleaned[cleaned_name] = kaggle_id


                    json_file_count += 1
                except Exception as e:
                    # print(f"Error parsing {json_path} for mapping: {e}") # Optional: print parsing errors
                    pass # Silently skip files that cause parsing errors

    print(f"총 {json_file_count}개 JSON 파일 스캔 완료")
    print(f"어노테이션 기반 매핑된 고유 클래스 수: {len(name_to_kaggle_id_cleaned)}")
else:
    print(f"[경고] Annotation directory not found at {ANNOTATION_BASE_DIR}. Cannot generate Kaggle ID mapping.")
    # If annotations are not available, we cannot create the desired mapping.
    name_to_kaggle_id_cleaned = {} # Ensure it's empty if annotations are missing


# --- 3. YOLO 클래스 이름과 Kaggle ID 매핑을 DataFrame으로 생성 ---
mapping_data = []
for yolo_name in yolo_class_names:
    # Clean the YOLO class name for lookup
    cleaned_yolo_name = yolo_name.replace(" ", "").replace('\xa0', '')
    kaggle_id = name_to_kaggle_id_cleaned.get(cleaned_yolo_name, None)

    if kaggle_id is not None:
        mapping_data.append({'알약 명': yolo_name, '알약 아이디': kaggle_id})
    else:
        print(f"[경고] YOLO 클래스 '{yolo_name}' (공백 제거: '{cleaned_yolo_name}')에 해당하는 Kaggle ID를 어노테이션에서 찾을 수 없습니다.")
        # Optionally add rows for unmapped classes with a placeholder ID
        # mapping_data.append({'알약 명': yolo_name, '알약 아이디': 'Not Found'})


df_pill_mapping = pd.DataFrame(mapping_data)

# --- 4. CSV 파일로 저장 ---
if not df_pill_mapping.empty:
    df_pill_mapping.to_csv(OUTPUT_CSV, index=False, encoding='utf-8')
    print(f"\n✅ 알약 매핑 CSV 파일 저장 완료: {OUTPUT_CSV}")
    print(f"총 {len(df_pill_mapping)}개 알약 매핑 저장됨")
    print("\n--- 샘플 매핑 결과 ---")
    display(df_pill_mapping.head(10))
else:
    print("\n[경고] 알약 매핑 데이터를 생성하지 못했습니다. 어노테이션 파일 또는 YOLO 클래스 파일을 확인하세요.")

