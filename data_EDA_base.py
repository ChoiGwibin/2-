# -*- coding: utf-8 -*-
"""경구약제 이미지 객체 검출.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n1Y0QXMo5sDayDkFAi1jcKNlMHps2uY8
"""

# 나눔고딕 모든 스타일 다운로드
font_files = {
    "NanumGothic-Regular.ttf": "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Regular.ttf",
    "NanumGothic-Bold.ttf": "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf",
    "NanumGothic-ExtraBold.ttf": "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-ExtraBold.ttf"
}

for filename, url in font_files.items():
    !wget -O "{font_dir}/{filename}" "{url}"

print("모든 나눔고딕 폰트 다운로드 완료!")

import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import warnings
warnings.filterwarnings('ignore')

font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'  # 또는 Regular, ExtraBold

# 폰트 등록
fm.fontManager.addfont(font_path)
font_prop = fm.FontProperties(fname=font_path)
font_name = font_prop.get_name()

plt.rc('font', family=font_name)
plt.rcParams['axes.unicode_minus'] = False

print(f"한글 폰트 설정 완료: {font_name}")

plt.figure(figsize=(6, 3))
plt.title("한글 제목 테스트")
plt.xlabel("X축 라벨")
plt.ylabel("Y축 라벨")
plt.text(0.5, 0.5, "한글 테스트 문구", fontsize=14, ha='center')
plt.show()

from google.colab import files
files.upload()  # 다운로드한 kaggle.json 파일을 업로드

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json  # 보안을 위해 권한 설정

!pip install kaggle

# 데이터 불러오기
!kaggle competitions download -c ai04-level1-project

!unzip ai04-level1-project.zip -d ./data/

import os
print(os.listdir('./data'))  # 압축 해제된 폴더 내 파일 확인

# train_image , annoation 시각화
import os
import json
import cv2
from pathlib import Path
import random

# 총 이미지 개수 확인
import glob

IMAGE_DIR = './data/train_images'
png_files = glob.glob(f"{IMAGE_DIR}/*.png") + glob.glob(f"{IMAGE_DIR}/*.PNG")

print("="*50)
print(f"이미지 폴더: {IMAGE_DIR}")
print(f"총 PNG 파일 수: {len(png_files)}개")
print("="*50)

# test 이미지 총 개수 확인
IMAGE_DIR = './data/test_images'
png_files = glob.glob(f"{IMAGE_DIR}/*.png") + glob.glob(f"{IMAGE_DIR}/*.PNG")

print("="*50)
print(f"이미지 폴더: {IMAGE_DIR}")
print(f"총 PNG 파일 수: {len(png_files)}개")
print("="*50)

import os
import json
import cv2
import matplotlib.pyplot as plt
import glob
import random

# --- 경로 설정 ---
IMAGE_DIR = './data/train_images'
ANNOTATION_BASE_DIR = './data/train_annotations'

# --- 랜덤으로 3개 이미지 선택 ---
all_png_files = glob.glob(os.path.join(IMAGE_DIR, "*.png"))
if len(all_png_files) == 0:
    raise FileNotFoundError(f"이미지 폴더에 PNG 파일이 없습니다: {IMAGE_DIR}")

# 파일명만 추출 (경로 제거)
all_image_filenames = [os.path.basename(f) for f in all_png_files]

# 랜덤 샘플링 (3개, 중복 없음)
random_image_filenames = random.sample(all_image_filenames, min(3, len(all_image_filenames)))

print(f"랜덤 선택된 이미지 {len(random_image_filenames)}개:")
for i, fname in enumerate(random_image_filenames, 1):
    print(f"  {i}. {fname}")

# --- 각 이미지에 대해 반복 시각화 ---
for image_filename in random_image_filenames:
    print(f"\n{'='*80}")
    print(f"처리 중: {image_filename}")
    print(f"{'='*80}")

    # --- 1. 이미지 로드 ---
    image_path = os.path.join(IMAGE_DIR, image_filename)
    if not os.path.exists(image_path):
        print(f"이미지 파일을 찾을 수 없습니다: {image_path}")
        continue

    image = cv2.imread(image_path)
    if image is None:
        print(f"이미지 로드 실패: {image_path}")
        continue
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # --- 2. 접두사 추출 및 폴더명 생성 ---
    prefix_part = image_filename.split('_')[0]
    prefixes_raw = prefix_part.split('-')[1:]
    prefix_folders = [f"K-{p}" for p in prefixes_raw]

    annotation_folder_name = prefix_part + "_json"
    annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

    if not os.path.exists(annotation_folder_path):
        print(f"어노테이션 폴더를 찾을 수 없습니다: {annotation_folder_path}")
        continue

    # --- 3. 각 접두사 폴더에서 JSON 파일 찾기 ---
    json_files_to_load = []
    for folder_name in prefix_folders:
        subfolder_path = os.path.join(annotation_folder_path, folder_name)
        if not os.path.exists(subfolder_path):
            print(f"Warning: Subfolder {subfolder_path} not found. Skipping...")
            continue

        json_filename = os.path.splitext(image_filename)[0] + ".json"
        json_path = os.path.join(subfolder_path, json_filename)

        if os.path.exists(json_path):
            json_files_to_load.append(json_path)
            print(f"Found: {json_path}")
        else:
            print(f"Not found: {json_path}")

    print(f"\n총 {len(json_files_to_load)}개의 어노테이션 파일을 찾았습니다.")

    # --- 4. 시각화 준비 ---
    fig, ax = plt.subplots(1, figsize=(15, 10))
    ax.imshow(image)
    ax.set_title(f"{image_filename} - {len(json_files_to_load)}개 어노테이션", fontsize=14, weight='bold')
    ax.axis('off')

    colors = ['red', 'blue', 'green', 'orange', 'purple', 'cyan']

    # --- 5. 각 JSON 파일 파싱 및 시각화 ---
    for idx, json_path in enumerate(json_files_to_load):
        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"JSON 로드 실패: {json_path} - {e}")
            continue

        # 필요한 키들 확인
        if 'images' not in data or 'annotations' not in data or 'categories' not in data:
            print(f"필수 키(images/annotations/categories) 누락: {json_path}")
            continue

        images = data['images']
        annotations = data['annotations']
        categories = data['categories']

        # 카테고리 ID -> 이름 매핑
        category_map = {cat['id']: cat['name'] for cat in categories}

        # 이미지 ID 찾기 (파일명 기반)
        image_id = None
        for img_info in images:
            if img_info.get('file_name') == image_filename:
                image_id = img_info['id']
                break

        if image_id is None:
            print(f"이미지 ID를 찾을 수 없습니다 (파일명: {image_filename}) in {json_path}")
            continue

        # 해당 image_id에 맞는 annotation 찾기
        matched_annotations = [ann for ann in annotations if ann.get('image_id') == image_id]

        if not matched_annotations:
            print(f"image_id={image_id}에 해당하는 annotation이 없습니다 in {json_path}")
            continue

        color = colors[idx % len(colors)]

        for ann in matched_annotations:
            bbox = ann.get('bbox')  # [x, y, width, height]
            if not bbox or len(bbox) != 4:
                print(f"잘못된 bbox 형식: {bbox} in {json_path}")
                continue

            x, y, w, h = bbox
            category_id = ann.get('category_id', 0)
            label = category_map.get(category_id, f"Class {category_id}")

            # 사각형 그리기
            rect = plt.Rectangle(
                (x, y), w, h,
                linewidth=3, edgecolor=color, facecolor='none'
            )
            ax.add_patch(rect)
            ax.text(x, y - 5, f"{label} ({folder_name})", color=color, fontsize=10, weight='bold',
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="yellow", alpha=0.5))

            print(f"그린 박스: {label} at ({x:.0f}, {y:.0f}, {w:.0f}, {h:.0f})")

    plt.tight_layout()
    plt.show()

!cat ./data/train_annotations/K-001900-010224-016551-031705_json/K-001900/K-001900-010224-016551-031705_0_2_0_2_70_000_200.json

import os
import json

ANNOTATION_BASE_DIR = './data/train_annotations'

# 모든 알약 종류(name)를 저장할 set (중복 자동 제거)
all_pill_names = set()

# train_annotations 하위 모든 .json 파일 찾기
json_file_paths = []
for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_file_paths.append(os.path.join(root, file))

print(f"총 {len(json_file_paths)}개의 JSON 파일을 찾았습니다.")

# 각 JSON 파일 파싱
for json_path in json_file_paths:
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # JSON 구조 확인 및 'categories' 키 접근
        # 데이터셋의 JSON 구조에 따라 'root'와 같은 최상위 키가 있을 수 있으므로 확인
        if 'root' in data and isinstance(data['root'], dict):
            data = data['root'] # 'root' 키가 있으면 그 하위 데이터를 사용
        # else: data 변수는 이미 로드된 최상위 dict

        # categories 키 확인
        if 'categories' not in data or not isinstance(data['categories'], list):
             # print(f"Warning: 'categories' key missing or not a list in {json_path}. Skipping.")
             continue

        categories = data['categories']

        # 각 카테고리에서 name 추출
        for cat in categories:
            if isinstance(cat, dict) and 'name' in cat: # 여기서 'name' in cat 으로 수정
                pill_name = cat['name']
                all_pill_names.add(pill_name)
            # else:
                # print(f"Warning: Invalid category format found in {json_path}: {cat}")


    except Exception as e:
        print(f"파일 파싱 중 오류: {json_path} - {e}")
        continue

# 결과 정렬 및 출력
sorted_pill_names = sorted(list(all_pill_names))

print(f"\n총 {len(sorted_pill_names)}개의 고유 알약 종류를 찾았습니다.\n")
print("="*80)
for i, name in enumerate(sorted_pill_names, 1):
    print(f"{i:3d}. {name}")
print("="*80)

from collections import defaultdict

ANNOTATION_BASE_DIR = './data/train_annotations'

# 알약 종류별 등장 횟수를 저장할 딕셔너리
pill_name_count = defaultdict(int)

# train_annotations 하위 모든 .json 파일 찾기
json_file_paths = []
for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_file_paths.append(os.path.join(root, file))

print(f"총 {len(json_file_paths)}개의 JSON 파일을 찾았습니다.")

# 각 JSON 파일 파싱
for json_path in json_file_paths:
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # 'root' 키가 있는 경우 처리
        if 'root' in data and isinstance(data['root'], dict):
            data = data['root']

        # categories 키 확인
        # Modified: Check 'categories' not in data
        if 'categories' not in data or not isinstance(data.get('categories'), list):
            continue

        categories = data['categories']

        # 각 카테고리에서 name 추출 및 카운트
        for cat in categories:
            # Modified: Check 'name' in cat
            if isinstance(cat, dict) and 'name' in cat:
                pill_name = cat['name']
                pill_name_count[pill_name] += 1

    except Exception as e:
        print(f"파일 파싱 중 오류: {json_path} - {e}")
        continue

# 빈도수 기준으로 정렬 (내림차순)
sorted_pill_counts = sorted(pill_name_count.items(), key=lambda x: x[1], reverse=True)

# 상위 20개만 선택 (너무 많으면 그래프가 복잡해지므로)
top_n = 20
top_pills = sorted_pill_counts[:top_n]
labels = [item[0] for item in top_pills]
counts = [item[1] for item in top_pills]

print(f"\n상위 {top_n}개 알약 종류 (빈도수 기준)\n")
print("="*80)
for i, (name, count) in enumerate(top_pills, 1):
    print(f"{i:2d}. {name} → {count}회")
print("="*80)

# --- 그래프 시각화 ---
plt.figure(figsize=(14, 8))
bars = plt.bar(range(len(labels)), counts, color='steelblue', edgecolor='black')

# 라벨 설정
plt.title(f'상위 {top_n}개 알약 종류별 등장 빈도', fontsize=16, weight='bold')
plt.xlabel('알약 종류', fontsize=12)
plt.ylabel('등장 횟수 (JSON 파일 기준)', fontsize=12)
plt.xticks(range(len(labels)), labels, rotation=45, ha='right', fontsize=10)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# 막대 위에 숫자 표시
for bar, count in zip(bars, counts):
    plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.5, str(count),
             ha='center', va='bottom', fontsize=10, weight='bold')

plt.tight_layout()
plt.show()

import os
import json
import matplotlib.pyplot as plt
from collections import defaultdict
import matplotlib as mpl # Import matplotlib for font settings

ANNOTATION_BASE_DIR = './data/train_annotations'

# 알약 종류별 등장 횟수를 저장할 딕셔너리
pill_name_count = defaultdict(int)

# train_annotations 하위 모든 .json 파일 찾기
json_file_paths = []
for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_file_paths.append(os.path.join(root, file))

print(f"총 {len(json_file_paths)}개의 JSON 파일을 찾았습니다.")

# 각 JSON 파일 파싱
for json_path in json_file_paths:
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # 'root' 키가 있는 경우 처리
        if 'root' in data and isinstance(data['root'], dict): # 수정: 'root' in data 로 변경
            data = data['root']

        # categories 키 확인
        # Modified: Check 'categories' not in data
        if 'categories' not in data or not isinstance(data.get('categories'), list): # 수정: 'categories' not in data 로 변경
            continue

        categories = data['categories']

        # 각 카테고리에서 name 추출 및 카운트
        for cat in categories:
            # Modified: Check 'name' in cat
            if isinstance(cat, dict) and 'name' in cat: # 수정: 'name' in cat 로 변경
                pill_name = cat['name']
                pill_name_count[pill_name] += 1

    except Exception as e:
        print(f"파일 파싱 중 오류: {json_path} - {e}")
        continue

# 빈도수 기준으로 정렬 (내림차순)
sorted_pill_counts = sorted(pill_name_count.items(), key=lambda x: x[1], reverse=True)

# 전체 항목 사용
all_pills = sorted_pill_counts
labels = [item[0] for item in all_pills]
counts = [item[1] for item in all_pills]

total_types = len(labels)
print(f"\n총 {total_types}개의 알약 종류 (빈도수 기준 전체 목록)\n")
print("="*80)
for i, (name, count) in enumerate(all_pills, 1):
    print(f"{i:3d}. {name} → {count}회")
print("="*80)

# --- 전체 알약 종류 그래프 시각화 ---
# 그래프 높이를 항목 수에 비례하여 자동 조정 (최소 10, 최대 50)
fig_height = max(10, min(50, total_types * 0.3))

plt.figure(figsize=(14, fig_height))
bars = plt.barh(range(len(labels)), counts, color='steelblue', edgecolor='black', height=0.7)

# 라벨 설정 (가로 막대 그래프로 변경 → 라벨이 길어도 잘 보임)
plt.title(f'전체 {total_types}개 알약 종류별 등장 빈도', fontsize=16, weight='bold')
plt.xlabel('등장 횟수 (JSON 파일 기준)', fontsize=12)
plt.ylabel('알약 종류', fontsize=12)
plt.yticks(range(len(labels)), labels, fontsize=9)  # 가로 그래프라 yticks에 라벨
plt.gca().invert_yaxis()  # 가장 빈도 높은 항목이 위로 오게
plt.grid(axis='x', linestyle='--', alpha=0.7)

# 막대 옆에 숫자 표시
for bar, count in zip(bars, counts):
    plt.text(bar.get_width() + 0.5, bar.get_y() + bar.get_height()/2, str(count),
             va='center', fontsize=9, weight='bold')

plt.tight_layout()

# 너무 길면 저장을 권장
plt.savefig('pill_frequency_full.png', dpi=150, bbox_inches='tight')
print("그래프가 'pill_frequency_full.png' 파일로 저장되었습니다.")

plt.show()

import os
import glob

IMAGE_DIR = './data/train_images'
ANNOTATION_BASE_DIR = './data/train_annotations'

# 모든 이미지 파일 목록 가져오기
image_files = glob.glob(os.path.join(IMAGE_DIR, "*.png"))
image_filenames = [os.path.basename(f) for f in image_files]

print(f"총 이미지 수: {len(image_filenames)}")

# 누락이 있는 이미지 개수 카운터
images_with_missing_annotations = 0

# (선택) 상세 목록 저장용
images_missing_list = []

for image_filename in image_filenames:
    # --- 접두사 추출 ---
    prefix_part = image_filename.split('_')[0]  # "K-002483-012081-022627-025438"
    prefixes_raw = prefix_part.split('-')[1:]   # ['002483', '012081', '022627', '025438']
    prefix_folders = [f"K-{p}" for p in prefixes_raw]

    annotation_folder_name = prefix_part + "_json"
    annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

    found_count = 0

    # 어노테이션 폴더가 없으면 → 4개 모두 누락 → 누락 있음
    if not os.path.exists(annotation_folder_path):
        images_with_missing_annotations += 1
        images_missing_list.append(image_filename)
        continue

    # 각 접두사 폴더에서 JSON 파일 찾기
    for folder_name in prefix_folders:
        subfolder_path = os.path.join(annotation_folder_path, folder_name)
        if not os.path.exists(subfolder_path):
            continue

        json_filename = os.path.splitext(image_filename)[0] + ".json"
        json_path = os.path.join(subfolder_path, json_filename)

        if os.path.exists(json_path):
            found_count += 1

    # 4개 미만이면 → 누락 있음
    if found_count < 4:
        images_with_missing_annotations += 1
        images_missing_list.append(image_filename)

# --- 결과 출력 ---
print(f"어노테이션 누락이 있는 이미지 수: {images_with_missing_annotations}")
print(f"→ 전체 이미지 대비 비율: {images_with_missing_annotations / len(image_filenames) * 100:.2f}%")

# --- (선택) 상세 목록 처음 10개만 출력 ---
if images_missing_list:
    print(f"\n[어노테이션 누락이 있는 이미지 목록 - 상위 10개]")
    print("="*80)
    for i, name in enumerate(images_missing_list[:10], 1):
        print(f"{i:3d}. {name}")
    if len(images_missing_list) > 10:
        print("    ... (생략)")
    print("="*80)

# 어노테이션이 누락된 알약 종류
IMAGE_DIR = './data/train_images'
ANNOTATION_BASE_DIR = './data/train_annotations'

# 1. 접두사 → 알약 이름 매핑 테이블 생성
prefix_to_pill_name = {}

# 모든 JSON 파일 탐색
json_file_paths = []
for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_file_paths.append(os.path.join(root, file))

print(f"총 {len(json_file_paths)}개의 JSON 파일을 스캔하여 접두사-알약명 매핑 중...")

for json_path in json_file_paths:
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # 'root' 키 처리
        if 'root' in data and isinstance(data['root'], dict):
            data = data['root']

        # categories와 images 키 확인
        if 'categories' not in data or 'images' not in data: # Modified: Added 'data'
            continue

        categories = data['categories']
        images = data['images']

        if not categories or not images:
            continue

        # 첫 번째 이미지에서 drug_N (접두사) 추출, 첫 번째 카테고리에서 name 추출
        img_info = images[0]
        drug_N = img_info.get('drug_N')  # 예: "K-001900"
        # 'categories' 리스트가 비어있지 않은지 추가 확인
        pill_name = categories[0].get('name')  # 예: "보령부스파정 5mg"

        if drug_N and pill_name:
            # 이미 매핑된 이름과 다르면 경고 (선택 사항)
            if drug_N in prefix_to_pill_name and prefix_to_pill_name[drug_N] != pill_name:
                print(f"경고: {drug_N}에 대해 다른 이름 발견됨 - 기존: {prefix_to_pill_name[drug_N]}, 신규: {pill_name}")
            prefix_to_pill_name[drug_N] = pill_name

    except Exception as e:
        # print(f"파일 파싱 중 오류: {json_path} - {e}") # 디버깅용 출력 (주석 처리)
        continue  # 오류난 파일은 건너뜀

print(f"매핑된 고유 접두사 수: {len(prefix_to_pill_name)}")

# 2. 이미지별 누락된 접두사 수집 + 알약 종류 기준 누락 카운트
pill_name_missing_count = defaultdict(int)

image_files = glob.glob(os.path.join(IMAGE_DIR, "*.png"))
image_filenames = [os.path.basename(f) for f in image_files]

print(f"\n총 이미지 수: {len(image_filenames)} → 누락된 알약 종류 집계 중...")

for image_filename in image_filenames:
    prefix_part = image_filename.split('_')[0]  # "K-002483-012081-022627-025438"
    prefixes_raw = prefix_part.split('-')[1:]   # ['002483', '012081', '022627', '025438']
    prefix_folders = [f"K-{p}" for p in prefixes_raw]

    annotation_folder_name = prefix_part + "_json"
    annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

    for folder_name in prefix_folders:
        subfolder_path = os.path.join(annotation_folder_path, folder_name)
        json_filename = os.path.splitext(image_filename)[0] + ".json"
        json_path = os.path.join(subfolder_path, json_filename)

        # 파일 또는 폴더가 없으면 → 누락
        if not os.path.exists(subfolder_path) or not os.path.exists(json_path):
            # 접두사(folder_name) → 알약 종류로 변환
            pill_name = prefix_to_pill_name.get(folder_name, folder_name)  # 매핑 없으면 접두사 그대로
            pill_name_missing_count[pill_name] += 1

# 3. 알약 종류별 누락 횟수 정렬 (내림차순)
sorted_pill_missing = sorted(pill_name_missing_count.items(), key=lambda x: x[1], reverse=True)

# 전체 항목 사용
labels = [item[0] for item in sorted_pill_missing]
counts = [item[1] for item in sorted_pill_missing]

total_pill_types = len(labels)
print(f"\n총 {total_pill_types}개 알약 종류에 대해 누락 집계 완료")
print("="*80)
for i, (name, count) in enumerate(sorted_pill_missing[:20], 1):  # 상위 20개만 미리보기
    print(f"{i:3d}. {name} → {count}회 누락")
if total_pill_types > 20:
    print("    ... (전체는 그래프에서 확인)")
print("="*80)

# 4. 그래프 시각화 — 전체 항목 (가로 막대 그래프)
fig_height = max(10, min(100, total_pill_types * 0.3))  # 최대 100 높이 제한

plt.figure(figsize=(14, fig_height))
bars = plt.barh(range(len(labels)), counts, color='lightcoral', edgecolor='black', height=0.7)

plt.title(f'누락된 알약 종류별 횟수 (총 {total_pill_types}종)', fontsize=16, weight='bold')
plt.xlabel('누락 횟수', fontsize=12)
plt.ylabel('알약 종류', fontsize=12)
plt.yticks(range(len(labels)), labels, fontsize=8)
plt.gca().invert_yaxis()  # 가장 많이 누락된 항목이 위로
plt.grid(axis='x', linestyle='--', alpha=0.7)

# 막대 옆에 숫자 표시
for bar, count in zip(bars, counts):
    plt.text(bar.get_width() + 0.5, bar.get_y() + bar.get_height()/2, str(count),
             va='center', fontsize=8, weight='bold')

plt.tight_layout()
plt.savefig('missing_pill_names_full.png', dpi=150, bbox_inches='tight')
print("그래프가 'missing_pill_names_full.png' 파일로 저장되었습니다.")
plt.show()

!pip install ultralytics

import os
import json
import shutil
import random
from pathlib import Path
from sklearn.model_selection import train_test_split
import cv2

ANNOTATION_BASE_DIR = './data/train_annotations'
OUTPUT_DIR = './yolo_dataset_leaky'  # "leaky" = 불완전 라벨 포함

# 출력 폴더 생성
Path(f"{OUTPUT_DIR}/images/train").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/images/val").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/labels/train").mkdir(parents=True, exist_ok=True)
Path(f"{OUTPUT_DIR}/labels/val").mkdir(parents=True, exist_ok=True)

# 클래스 이름 → ID 매핑

class_name_to_id = {}
next_class_id = 0

json_paths = []
for root, dirs, files in os.walk(ANNOTATION_BASE_DIR):
    for file in files:
        if file.endswith('.json'):
            json_paths.append(os.path.join(root, file))

for json_path in json_paths:
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # 수정: if 'root' in data 로 변경
            if 'root' in data and isinstance(data['root'], dict):
                data = data['root']

            # 수정: if 'categories' not in data 로 변경
            if 'categories' not in data or not isinstance(data.get('categories'), list):
                continue

            for cat in data['categories']:
                # 수정: if isinstance(cat, dict) and 'name' in cat 으로 변경
                if isinstance(cat, dict) and 'name' in cat:
                    name = cat['name']
                    if name not in class_name_to_id:
                        class_name_to_id[name] = next_class_id
                        next_class_id += 1
    except Exception as e: # Added exception handling for parsing errors
        print(f"Error parsing {json_path}: {e}")
        continue

print(f"총 클래스 수: {len(class_name_to_id)}")
with open(f"{OUTPUT_DIR}/classes.txt", 'w', encoding='utf-8') as f:
    for name in sorted(class_name_to_id.keys(), key=lambda x: class_name_to_id[x]):
        f.write(name + '\n')

IMAGE_DIR = './data/train_images'

def convert_coco_to_yolo(bbox, img_width, img_height):
    x, y, w, h = bbox
    x_center = (x + w / 2) / img_width
    y_center = (y + h / 2) / img_height
    w_norm = w / img_width
    h_norm = h / img_height
    return x_center, y_center, w_norm, h_norm

# 유효 이미지 수집 (어노테이션 1개 이상)
valid_images = []

image_files = [f for f in os.listdir(IMAGE_DIR) if f.endswith('.png')]

for image_filename in image_files:
    prefix_part = image_filename.split('_')[0]
    prefixes_raw = prefix_part.split('-')[1:]
    prefix_folders = [f"K-{p}" for p in prefixes_raw]
    annotation_folder_name = prefix_part + "_json"
    annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

    if not os.path.exists(annotation_folder_path):
        continue

    has_any_annotation = False
    for folder_name in prefix_folders:
        subfolder_path = os.path.join(annotation_folder_path, folder_name)
        if not os.path.exists(subfolder_path):
            continue

        json_filename = os.path.splitext(image_filename)[0] + ".json"
        json_path = os.path.join(subfolder_path, json_filename)

        if os.path.exists(json_path):
            has_any_annotation = True
            break  # 하나라도 있으면 OK

    if has_any_annotation:
        valid_images.append(image_filename)

print(f"어노테이션이 1개 이상 있는 유효 이미지 수: {len(valid_images)}")

train_images, val_images = train_test_split(valid_images, test_size=0.2, random_state=42)
print(f"Train: {len(train_images)}, Val: {len(val_images)}")

def process_image_list(image_list, split):
    image_target_dir = f"{OUTPUT_DIR}/images/{split}"
    label_target_dir = f"{OUTPUT_DIR}/labels/{split}"

    for image_filename in image_list:
        # 이미지 복사
        src_img_path = os.path.join(IMAGE_DIR, image_filename)
        dst_img_path = os.path.join(image_target_dir, image_filename)
        shutil.copy2(src_img_path, dst_img_path)

        # 라벨 파일 생성 (어노테이션 있는 것만)
        label_filename = os.path.splitext(image_filename)[0] + ".txt"
        label_path = os.path.join(label_target_dir, label_filename)

        prefix_part = image_filename.split('_')[0]
        prefixes_raw = prefix_part.split('-')[1:]
        prefix_folders = [f"K-{p}" for p in prefixes_raw]
        annotation_folder_name = prefix_part + "_json"
        annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

        # 이미지 크기 읽기
        img = cv2.imread(src_img_path)
        if img is None:
            print(f"이미지 로드 실패: {src_img_path}")
            continue
        img_height, img_width = img.shape[:2]

        annotations_written = 0

        with open(label_path, 'w', encoding='utf-8') as f:
            for folder_name in prefix_folders:
                subfolder_path = os.path.join(annotation_folder_path, folder_name)
                json_filename = os.path.splitext(image_filename)[0] + ".json"
                json_path = os.path.join(subfolder_path, json_filename)

                if not os.path.exists(json_path):
                    continue

                try:
                    with open(json_path, 'r', encoding='utf-8') as jf:
                        data = json.load(jf)
                        if 'root' in data and isinstance(data['root'], dict):
                            data = data['root']

                        # 이미지 ID 찾기
                        image_id = None
                        for img_info in data.get('images', []):
                            if img_info.get('file_name') == image_filename:
                                image_id = img_info['id']
                                break

                        if image_id is None:
                            continue

                        # 해당 image_id의 annotations 찾기
                        annotations = [
                            ann for ann in data.get('annotations', [])
                            if ann.get('image_id') == image_id
                        ]

                        for ann in annotations:
                            bbox = ann.get('bbox')
                            if not bbox or len(bbox) != 4:
                                continue

                            category_id = ann.get('category_id')
                            cat_name = None
                            for cat in data.get('categories', []):
                                if cat.get('id') == category_id:
                                    cat_name = cat.get('name')
                                    break

                            if cat_name is None or cat_name not in class_name_to_id:
                                continue

                            cls_id = class_name_to_id[cat_name]
                            x_center, y_center, w_norm, h_norm = convert_coco_to_yolo(bbox, img_width, img_height)
                            f.write(f"{cls_id} {x_center:.6f} {y_center:.6f} {w_norm:.6f} {h_norm:.6f}\n")
                            annotations_written += 1

                except Exception as e:
                    print(f"파싱 오류: {json_path} - {e}")
                    continue

        # 어노테이션이 하나도 없으면 빈 파일로 남아있음 → 삭제 가능 (선택)
        if annotations_written == 0:
            os.remove(label_path)
            print(f"{label_path} 삭제됨 — 어노테이션 없음")

# Train 처리
print("Train 이미지 처리 중...")
process_image_list(train_images, 'train')

# Val 처리
print("Val 이미지 처리 중...")
process_image_list(val_images, 'val')

print("YOLO 형식 변환 완료 (누락 어노테이션 포함)!")

train_img_abs = os.path.abspath(f"{OUTPUT_DIR}/images/train")
val_img_abs = os.path.abspath(f"{OUTPUT_DIR}/images/val")

yaml_content = f"""train: {train_img_abs}
val: {val_img_abs}

nc: {len(class_name_to_id)}
names: {list(class_name_to_id.keys())}
"""

with open(f"{OUTPUT_DIR}/dataset.yaml", 'w', encoding='utf-8') as f:
    f.write(yaml_content)

print("dataset.yaml 생성 완료 (절대 경로 사용)")

from ultralytics import YOLO
# leaky_model
leaky_model = YOLO('yolov8n.pt')  # 또는 yolov8s.pt, yolov8m.pt 등

leaky_results = leaky_model.train(
    data=f'{OUTPUT_DIR}/dataset.yaml',
    epochs=100,
    imgsz=640,
    batch=16,
    name='pill_detection_leaky',
    patience=10,
    save=True,
    plots=True,
    val=True,
    device=0
)

leaky_final_map = leaky_results.results_dict['metrics/mAP50-95(B)']
print(f"최종 mAP@0.5:0.95: {leaky_final_map:.4f}")

def convert_coco_to_yolo(bbox, img_width, img_height):
    x, y, w, h = bbox
    x_center = (x + w / 2) / img_width
    y_center = (y + h / 2) / img_height
    w_norm = w / img_width
    h_norm = h / img_height
    return x_center, y_center, w_norm, h_norm

# 완전한 어노테이션을 가진 이미지 수집
complete_images = []

image_files = [f for f in os.listdir(IMAGE_DIR) if f.endswith('.png')]

for image_filename in image_files:
    prefix_part = image_filename.split('_')[0]
    prefixes_raw = prefix_part.split('-')[1:]
    prefix_folders = [f"K-{p}" for p in prefixes_raw]
    annotation_folder_name = prefix_part + "_json"
    annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

    if not os.path.exists(annotation_folder_path):
        continue

    found_count = 0
    for folder_name in prefix_folders:
        subfolder_path = os.path.join(annotation_folder_path, folder_name)
        if not os.path.exists(subfolder_path):
            break  # 폴더가 없으면 완전하지 않음

        json_filename = os.path.splitext(image_filename)[0] + ".json"
        json_path = os.path.join(subfolder_path, json_filename)

        if not os.path.exists(json_path):
            break  # JSON이 없으면 완전하지 않음

        found_count += 1

    # 4개 모두 있어야 포함
    if found_count == 4:
        complete_images.append(image_filename)

print(f"완전한 어노테이션(4/4)을 가진 이미지 수: {len(complete_images)}")

if len(complete_images) == 0:
    raise ValueError("완전한 어노테이션을 가진 이미지가 없습니다!")

train_images, val_images = train_test_split(complete_images, test_size=0.2, random_state=42)
print(f"Train: {len(train_images)}, Val: {len(val_images)}")

def process_image_list(image_list, split):
    image_target_dir = f"{OUTPUT_DIR}/images/{split}"
    label_target_dir = f"{OUTPUT_DIR}/labels/{split}"

    for image_filename in image_list:
        # 이미지 복사
        src_img_path = os.path.join(IMAGE_DIR, image_filename)
        dst_img_path = os.path.join(image_target_dir, image_filename)
        shutil.copy2(src_img_path, dst_img_path)

        # 라벨 파일 생성
        label_filename = os.path.splitext(image_filename)[0] + ".txt"
        label_path = os.path.join(label_target_dir, label_filename)

        prefix_part = image_filename.split('_')[0]
        prefixes_raw = prefix_part.split('-')[1:]
        prefix_folders = [f"K-{p}" for p in prefixes_raw]
        annotation_folder_name = prefix_part + "_json"
        annotation_folder_path = os.path.join(ANNOTATION_BASE_DIR, annotation_folder_name)

        # 이미지 크기 읽기
        img = cv2.imread(src_img_path)
        if img is None:
            print(f"이미지 로드 실패: {src_img_path}")
            continue
        img_height, img_width = img.shape[:2]

        with open(label_path, 'w', encoding='utf-8') as f:
            for folder_name in prefix_folders:
                subfolder_path = os.path.join(annotation_folder_path, folder_name)
                json_filename = os.path.splitext(image_filename)[0] + ".json"
                json_path = os.path.join(subfolder_path, json_filename)

                # 파일이 없으면 건너뜀 (이론상 여기까지 오면 모두 있어야 함)
                if not os.path.exists(json_path):
                    continue

                try:
                    with open(json_path, 'r', encoding='utf-8') as jf:
                        data = json.load(jf)
                        if 'root' in data and isinstance(data['root'], dict):
                            data = data['root']

                        # 이미지 ID 찾기
                        image_id = None
                        for img_info in data.get('images', []):
                            if img_info.get('file_name') == image_filename:
                                image_id = img_info['id']
                                break

                        if image_id is None:
                            continue

                        # 해당 image_id의 annotations 찾기
                        annotations = [
                            ann for ann in data.get('annotations', [])
                            if ann.get('image_id') == image_id
                        ]

                        for ann in annotations:
                            bbox = ann.get('bbox')
                            if not bbox or len(bbox) != 4:
                                continue

                            category_id = ann.get('category_id')
                            cat_name = None
                            for cat in data.get('categories', []):
                                if cat.get('id') == category_id:
                                    cat_name = cat.get('name')
                                    break

                            if cat_name is None or cat_name not in class_name_to_id:
                                continue

                            cls_id = class_name_to_id[cat_name]
                            x_center, y_center, w_norm, h_norm = convert_coco_to_yolo(bbox, img_width, img_height)
                            f.write(f"{cls_id} {x_center:.6f} {y_center:.6f} {w_norm:.6f} {h_norm:.6f}\n")

                except Exception as e:
                    print(f"파싱 오류: {json_path} - {e}")
                    continue

# Train 처리
print("Train 이미지 처리 중...")
process_image_list(train_images, 'train')

# Val 처리
print("Val 이미지 처리 중...")
process_image_list(val_images, 'val')

print("YOLO 형식 변환 완료 (완전한 어노테이션만 사용)!")

import os

train_img_abs = os.path.abspath(f"{OUTPUT_DIR}/images/train")
val_img_abs = os.path.abspath(f"{OUTPUT_DIR}/images/val")

yaml_content = f"""train: {train_img_abs}
val: {val_img_abs}

nc: {len(class_name_to_id)}
names: {list(class_name_to_id.keys())}
"""

with open(f"{OUTPUT_DIR}/dataset.yaml", 'w', encoding='utf-8') as f:
    f.write(yaml_content)

print("dataset.yaml 생성 완료!")
print(f"Train 경로: {train_img_abs}")
print(f"Val 경로: {val_img_abs}")

from ultralytics import YOLO
# complete_model -> 어노테이션 누락 제거
c_model = YOLO('yolov8n.pt')  # 또는 yolov8s.pt, yolov8m.pt

c_results = c_model.train(
    data=f'{OUTPUT_DIR}/dataset.yaml',
    epochs=100,
    imgsz=640,
    batch=16,
    name='pill_detection_complete',
    patience=10,
    save=True,
    plots=True,
    val=True,
    device=0
)

c_final_map = c_results.results_dict['metrics/mAP50-95(B)']
print(f"최종 mAP@0.5:0.95: {c_final_map:.4f}")

# --- 안정적인 폰트 설정 코드 (나눔고딕 사용) ---
import os
from google.colab import drive
from PIL import ImageFont

# Google Drive 마운트
try:
    drive.mount('/content/drive', force_remount=False)
except:
    pass

# 나눔고딕 Bold 사용 (BarunGothic 대체)
font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'
font_dir = os.path.dirname(font_path)
os.makedirs(font_dir, exist_ok=True)

if not os.path.exists(font_path):
    print("나눔고딕 폰트 없음 → Google Fonts에서 다운로드 시도 중...")
    !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf"

    # 다운로드 후 파일 크기 확인 (유효성 검사)
    if os.path.exists(font_path):
        file_size = os.path.getsize(font_path)
        if file_size < 1000:  # 1KB 미만 → HTML 오류 페이지 가능성
            print(f"❌ 파일이 너무 작습니다 ({file_size} bytes) — 삭제 후 재시도")
            !rm "{font_path}"
            # 대체 링크 시도
            !wget -O "{font_path}" "https://fonts.google.com/download?family=Nanum%20Gothic"  # ❌ 이건 zip임
            # → 안 됨, 대신 아래 공식 raw 링크 재시도
            !wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf"
        else:
            print(f"다운로드 성공 (파일 크기: {file_size} bytes)")
    else:
        raise FileNotFoundError("❌ 폰트 다운로드 실패")

# 파일 권한 설정
!chmod 644 "{font_path}"

# PIL로 폰트 로드 시도
try:
    font = ImageFont.truetype(font_path, 20)
    print(f"한글 폰트 로드 성공: {font_path}")
except Exception as e:
    print(f"❌ 폰트 로드 실패: {e}")

    # 마지막 대체 수단 — 기본 폰트
    font = ImageFont.load_default()
    print("기본 폰트 사용 — 한글은 깨질 수 있음")

import os
import cv2
import matplotlib.pyplot as plt
from ultralytics import YOLO
import random
from PIL import Image, ImageDraw, ImageFont
import numpy as np
from google.colab import drive

# --- 1. Google Drive 마운트 (폰트 로드용) ---
try:
    drive.mount('/content/drive', force_remount=False)
except:
    pass

# --- 2. 두 모델 로드 ---
# 이전에 학습된 모델 경로를 사용합니다.
# 'pill_detection_leaky2'와 'pill_detection_complete'는 이전 학습 실행에서 지정된 이름입니다.
model_leaky = YOLO('./runs/detect/pill_detection_leaky2/weights/best.pt')
model_complete = YOLO('./runs/detect/pill_detection_complete/weights/best.pt')

# --- 3. 테스트 이미지 준비 ---
TEST_IMAGE_DIR = './data/test_images'

if not os.path.exists(TEST_IMAGE_DIR):
    print("테스트 이미지 폴더 없음 → val 이미지에서 샘플링")
    from pathlib import Path
    # 'yolo_dataset_leaky' 또는 'yolo_dataset_complete' 중 하나를 사용해도 무방
    val_image_dir = './yolo_dataset_leaky/images/val'
    if not os.path.exists(val_image_dir):
         raise FileNotFoundError(f"Val 이미지 폴더도 찾을 수 없습니다: {val_image_dir}")
    test_images = random.sample(list(Path(val_image_dir).glob("*.png")), k=min(5, len(list(Path(val_image_dir).glob("*.png")))))
    test_image_paths = [str(p) for p in test_images]
else:
    test_image_paths = [os.path.join(TEST_IMAGE_DIR, f) for f in os.listdir(TEST_IMAGE_DIR) if f.endswith(('.png', '.jpg', '.jpeg'))]

if len(test_image_paths) == 0:
    raise FileNotFoundError("시각화할 테스트 이미지가 없습니다.")

print(f"총 {len(test_image_paths)}개 테스트 이미지 로드됨")

# --- 4. 클래스 이름 로드 ---
# 두 모델은 동일한 클래스를 사용하므로 하나만 로드합니다.
classes_file_path = './yolo_dataset_leaky/classes.txt' # 또는 ./yolo_dataset_complete/classes.txt
if not os.path.exists(classes_file_path):
     raise FileNotFoundError(f"클래스 파일이 없습니다: {classes_file_path}")

with open(classes_file_path, 'r', encoding='utf-8') as f:
    class_names = [line.strip() for line in f.readlines()]

print(f"총 {len(class_names)}개 클래스 이름 로드됨")


# --- 5. 한글 폰트 로드 (나눔고딕 Bold 사용) ---
# 이전에 성공했던 나눔고딕 Bold 폰트 경로를 사용합니다.
font_path = '/content/drive/MyDrive/fonts/NanumGothic-Bold.ttf'
font_size = 20 # 폰트 크기 설정

# 폰트 파일이 존재하는지 확인하고 없으면 다운로드 시도
if not os.path.exists(font_path):
    print(f"폰트 파일 없음: {font_path} → 다운로드 시도 중...")
    font_dir = os.path.dirname(font_path)
    os.makedirs(font_dir, exist_ok=True)
    # GitHub raw 파일 링크 또는 네이버 폰트 GitHub 링크 사용
    try:
        !wget -O "{font_path}" "https://raw.githubusercontent.com/google/fonts/main/ofl/nanumgothic/NanumGothic-Bold.ttf"
        # 다운로드 후 파일 크기 확인 (유효성 검사)
        if os.path.exists(font_path) and os.path.getsize(font_path) > 1000:
             print(f"폰트 다운로드 성공: {font_path}")
        else:
             print(f"폰트 다운로드 실패 또는 파일 유효하지 않음. 네이버 GitHub 링크 시도.")
             !wget -O "{font_path}" "https://github.com/naver/nanumfont/raw/master/NanumGothicBold.ttf"
             if os.path.exists(font_path) and os.path.getsize(font_path) > 1000:
                 print(f"폰트 다운로드 성공 (네이버 GitHub): {font_path}")
             else:
                 raise FileNotFoundError("모든 폰트 다운로드 시도 실패")
    except Exception as e:
         raise FileNotFoundError(f"폰트 다운로드 실패: {e}")


# PIL 폰트 객체 생성
try:
    font = ImageFont.truetype(font_path, font_size)
    print(f"한글 폰트 로드 성공: {font_path}, 크기: {font_size}")
except Exception as e:
    print(f"폰트 로드 실패: {e}")
    # 실패 시 기본 폰트 사용 (한글 깨짐 가능성 있음)
    font = ImageFont.load_default()
    print("기본 폰트 사용 — 한글은 깨질 수 있습니다.")


# --- 6. OpenCV 이미지에 한글 그리기 함수 (PIL 사용) ---
def put_text_korean(img, text, position, color):
    """
    OpenCV 이미지에 한글 텍스트를 그리는 함수 (PIL 사용)
    img: OpenCV 이미지 (BGR)
    text: 표시할 텍스트
    position: (x, y) 좌표
    color: (B, G, R) 튜플 (OpenCV 색상 순서)
    """
    # OpenCV 이미지를 PIL 이미지로 변환 (BGR to RGB)
    img_pil = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(img_pil)

    # PIL은 RGB 순서로 색상을 받음
    draw.text(position, text, font=font, fill=(color[2], color[1], color[0])) # BGR to RGB 순서 변환

    # 다시 OpenCV 이미지로 변환 (RGB to BGR)
    return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

# --- 7. 각 테스트 이미지에 대해 두 모델 추론 + 시각화 ---
for img_path in test_image_paths[:5]:  # 처음 5개만 시각화
    print(f"\n{'='*80}")
    print(f"처리 중: {os.path.basename(img_path)}")
    print(f"{'='*80}")

    # 이미지 로드 (BGR)
    img = cv2.imread(img_path)
    if img is None:
        print(f"이미지 로드 실패: {img_path}")
        continue

    # --- 두 모델 추론 ---
    # conf=0.3은 예시, 필요에 따라 조정
    results_leaky = model_leaky(img_path, conf=0.3, verbose=False)
    results_complete = model_complete(img_path, conf=0.3, verbose=False)

    # --- 시각화 준비 ---
    # Matplotlib Figure 생성 (PIL로 텍스트를 그리기 때문에 Matplotlib의 한글 설정은 필요 없음)
    fig, axes = plt.subplots(1, 2, figsize=(20, 10))

    # 모델 1: 누락 포함 (leaky) 결과 시각화
    img_leaky = img.copy()
    # YOLO 결과는 리스트 형태 (이미지당 하나)
    if results_leaky and hasattr(results_leaky[0], 'boxes'):
        for box in results_leaky[0].boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
            conf = float(box.conf[0])
            cls_id = int(box.cls[0])
            # 클래스 ID 유효성 검사
            label = class_names[cls_id] if 0 <= cls_id < len(class_names) else f"Unknown Class {cls_id}"
            text = f"{label} {conf:.2f}"

            # 박스 그리기 (파란색)
            cv2.rectangle(img_leaky, (x1, y1), (x2, y2), (255, 0, 0), 3)

            # 한글 텍스트 그리기 (PIL 사용)
            # 텍스트 위치 조정 (박스 위)
            text_position = (x1, y1 - font_size - 5)
            # 이미지를 넘어서지 않도록 조정 (선택 사항)
            if text_position[1] < 0:
                 text_position = (x1, y1 + 5) # 박스 아래로 이동

            img_leaky = put_text_korean(img_leaky, text, text_position, (255, 0, 0)) # 파란색

            # print(f"Leaky 모델 탐지: {text} at ({x1}, {y1}, {x2}, {y2})") # 디버깅용

    axes[0].imshow(cv2.cvtColor(img_leaky, cv2.COLOR_BGR2RGB)) # Matplotlib은 RGB
    axes[0].set_title("모델 A: 어노테이션 누락 포함 학습 결과", fontsize=14, weight='bold')
    axes[0].axis('off')

    # 모델 2: 완전한 어노테이션만 (complete) 결과 시각화
    img_complete = img.copy()
    if results_complete and hasattr(results_complete[0], 'boxes'):
        for box in results_complete[0].boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
            conf = float(box.conf[0])
            cls_id = int(box.cls[0])
             # 클래스 ID 유효성 검사
            label = class_names[cls_id] if 0 <= cls_id < len(class_names) else f"Unknown Class {cls_id}"
            text = f"{label} {conf:.2f}"

            # 박스 그리기 (초록색)
            cv2.rectangle(img_complete, (x1, y1), (x2, y2), (0, 255, 0), 3)

            # 한글 텍스트 그리기 (PIL 사용)
            # 텍스트 위치 조정 (박스 위)
            text_position = (x1, y1 - font_size - 5)
             # 이미지를 넘어서지 않도록 조정 (선택 사항)
            if text_position[1] < 0:
                 text_position = (x1, y1 + 5) # 박스 아래로 이동

            img_complete = put_text_korean(img_complete, text, text_position, (0, 255, 0)) # 초록색
            # print(f"Complete 모델 탐지: {text} at ({x1}, {y1}, {x2}, {y2})") # 디버깅용

    axes[1].imshow(cv2.cvtColor(img_complete, cv2.COLOR_BGR2RGB)) # Matplotlib은 RGB
    axes[1].set_title("모델 B: 완전한 어노테이션만 사용 학습 결과", fontsize=14, weight='bold')
    axes[1].axis('off')

    plt.tight_layout()
    plt.show()

print("\n시각화 완료!")

